<!doctype html><html><head><title>ImGui中使用Vulkan渲染窗口</title><base href="../../../"><meta id="root-path" root-path="../../../"><link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=yes,minimum-scale=1,maximum-scale=5"><meta charset="UTF-8"><link rel="stylesheet" href="lib/styles/obsidian-styles.css"><link rel="stylesheet" href="lib/styles/theme.css"><link rel="stylesheet" href="lib/styles/plugin-styles.css"><link rel="stylesheet" href="lib/styles/snippets.css"><link rel="stylesheet" href="lib/styles/generated-styles.css"><style></style><script type="module" src="lib/scripts/graph_view.js"></script><script src="lib/scripts/graph_wasm.js"></script><script src="lib/scripts/tinycolor.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><script>let webpageContainer,documentContainer,viewContent,leftSidebar,rightSidebar,sidebarCollapseIcons,sidebarGutters,sidebars,sidebarTargetWidth,contentTargetWidth,canvasWrapper,canvas,canvasNodes,canvasBackground,canvasBackgroundPattern,focusedCanvasNode,loadingIcon,documentType,embedType,customType,deviceSize,lastScreenWidth,isOffline=!1,collapseIconUp=["m7 15 5 5 5-5","m7 9 5-5 5 5"],collapseIconDown=["m7 20 5-5 5 5","m7 4 5 5 5-5"],isTouchDevice=isTouchCapable(),fullyInitialized=!1;function initGlobalObjects(){loadingIcon=document.createElement("div"),loadingIcon.classList.add("loading-icon"),document.body.appendChild(loadingIcon),loadingIcon.innerHTML="<div></div><div></div><div></div><div></div>",webpageContainer=document.querySelector(".webpage-container"),documentContainer=document.querySelector(".document-container"),leftSidebar=document.querySelector(".sidebar-left"),rightSidebar=document.querySelector(".sidebar-right"),sidebarCollapseIcons=Array.from(document.querySelectorAll(".sidebar-collapse-icon")),sidebarGutters=[sidebarCollapseIcons[0].parentElement,sidebarCollapseIcons[1].parentElement],sidebars=[sidebarGutters[0].parentElement,sidebarGutters[1].parentElement]}async function initializePage(){focusedCanvasNode=null,canvasWrapper=document.querySelector(".canvas-wrapper")??canvasWrapper,canvas=document.querySelector(".canvas")??canvas;let e=document.querySelectorAll(".canvas-node");canvasNodes=e.length>0?e:canvasNodes,canvasBackground=document.querySelector(".canvas-background")??canvasBackground,canvasBackgroundPattern=document.querySelector(".canvas-background pattern")??canvasBackgroundPattern,viewContent=document.querySelector(".document-container > .view-content")??document.querySelector(".document-container > .markdown-preview-view")??viewContent,fullyInitialized||(initGlobalObjects(),initializeDocumentTypes(),setupSidebars(),setupThemeToggle(),sidebarTargetWidth=await getComputedPixelValue("--sidebar-width"),contentTargetWidth=.9*await getComputedPixelValue("--line-width"),window.addEventListener("resize",(()=>onResize())),onResize(),document.body.classList.toggle("post-load",!0),document.body.classList.toggle("loading",!1),setTimeout((function(){document.body.classList.toggle("loaded",!0),document.body.classList.toggle("post-load",!1)}),2e3),fullyInitialized=!0),"video"==embedType||"embed"==embedType||"excalidraw"==customType||"kanban"==customType||"canvas"==documentType?rightSidebar.collapsed||rightSidebar.temporaryCollapse():rightSidebar.temporarilyCollapsed&&rightSidebar.collapsed&&(rightSidebar.collapse(!1),rightSidebar.temporarilyCollapsed=!1)}function initializePageEvents(e){setupHeaders(e),setupTrees(e),setupCallouts(e),setupCheckboxes(e),setupCanvas(e),setupCodeblocks(e),setupLinks(e),setupScroll(e)}function initializeDocumentTypes(){document.querySelector(".document-container > .markdown-preview-view")?documentType="markdown":document.querySelector(".canvas-wrapper")?documentType="canvas":(documentType="custom",document.querySelector(".kanban-plugin")?customType="kanban":document.querySelector(".excalidraw-plugin")&&(customType="excalidraw"))}function initializeForFileProtocol(){let e=document.querySelector(".graph-view-placeholder");e&&(console.log("Running locally, skipping graph view initialization and hiding graph."),e.style.display="none",e.previousElementSibling.style.display="none")}function onOffline(e){e.preventDefault(),e.stopPropagation(),console.log("Offline"),isOffline=!0}function onEndResize(){document.body.classList.toggle("resizing",!1)}function onStartResize(){document.body.classList.toggle("resizing",!0)}window.onload=async function(){"file:"==window.location.protocol&&initializeForFileProtocol(),await initializePage(),initializePageEvents(document)},window.addEventListener("offline",onOffline),window.onpopstate=function(e){if(e.preventDefault(),e.stopPropagation(),document.body.classList.contains("floating-sidebars")&&(!leftSidebar.collapsed||!rightSidebar.collapsed))return leftSidebar.collapse(!0),void rightSidebar.collapse(!0);loadDocument(getURLPath(),!1)};let checkStillResizingTimeout,isResizing=!1;function onResize(e=!1){function t(e,t){let o=window.innerWidth;return o>e&&o<t&&null==lastScreenWidth||o>e&&o<t&&(lastScreenWidth<=e||lastScreenWidth>=t)}isResizing||(onStartResize(),isResizing=!0),function(e){let t=window.innerWidth;return t>e&&null==lastScreenWidth||t>e&&lastScreenWidth<e}(contentTargetWidth+2*sidebarTargetWidth)?(deviceSize="large-screen",document.body.classList.toggle("floating-sidebars",!1),document.body.classList.toggle("is-large-screen",!0),document.body.classList.toggle("is-small-screen",!1),document.body.classList.toggle("is-tablet",!1),document.body.classList.toggle("is-phone",!1),sidebars.forEach((function(e){e.collapse(!1)})),document.body.classList.contains("sidebars-always-collapsible")?sidebarGutters.forEach((function(e){e.collapse(!1)})):sidebarGutters.forEach((function(e){e.collapse(!0)}))):t(contentTargetWidth+sidebarTargetWidth,contentTargetWidth+2*sidebarTargetWidth)?(deviceSize="small screen",document.body.classList.toggle("floating-sidebars",!1),document.body.classList.toggle("is-large-screen",!1),document.body.classList.toggle("is-small-screen",!0),document.body.classList.toggle("is-tablet",!1),document.body.classList.toggle("is-phone",!1),sidebarGutters.forEach((function(e){e.collapse(!1)})),leftSidebar.collapsed||rightSidebar.collapse(!0)):t(1.5*sidebarTargetWidth,contentTargetWidth+sidebarTargetWidth)?(deviceSize="tablet",document.body.classList.toggle("floating-sidebars",!0),document.body.classList.toggle("is-large-screen",!1),document.body.classList.toggle("is-small-screen",!1),document.body.classList.toggle("is-tablet",!0),document.body.classList.toggle("is-phone",!1),sidebarGutters.forEach((function(e){e.collapse(!1)})),leftSidebar.collapsed||rightSidebar.collapse(!0),fullyInitialized||leftSidebar.collapse(!0)):function(e){let t=window.innerWidth;return t<e&&null==lastScreenWidth||t<e&&lastScreenWidth>e}(1.5*sidebarTargetWidth)&&(deviceSize="phone",document.body.classList.toggle("floating-sidebars",!0),document.body.classList.toggle("is-large-screen",!1),document.body.classList.toggle("is-small-screen",!1),document.body.classList.toggle("is-tablet",!1),document.body.classList.toggle("is-phone",!0),sidebars.forEach((function(e){e.collapse(!0)})),sidebarGutters.forEach((function(e){e.collapse(!1)}))),lastScreenWidth=window.innerWidth,null!=checkStillResizingTimeout&&clearTimeout(checkStillResizingTimeout);let o=window.innerWidth;checkStillResizingTimeout=setTimeout((function(){window.innerWidth==o&&(checkStillResizingTimeout=void 0,isResizing=!1,onEndResize())}),200)}function clamp(e,t,o){return Math.min(Math.max(e,t),o)}function getElBounds(e){let t=e.getBoundingClientRect(),o=t.x,n=t.y,i=t.width,s=t.height;return{x:o,y:n,width:i,height:s,minX:o,minY:n,maxX:o+i,maxY:n+s,centerX:t.x+t.width/2,centerY:t.y+t.height/2}}async function getComputedPixelValue(e){const t=document.createElement("div");document.body.appendChild(t),t.style.position="absolute",t.style.width=`var(${e})`,await new Promise((e=>setTimeout(e,10)));const o=window.getComputedStyle(t).width;return t.remove(),parseFloat(o)}function getPointerPosition(e){let t=e.touches?Array.from(e.touches):[];return{x:t.length>0?t.reduce(((e,t)=>e+t.clientX),0)/e.touches.length:e.clientX,y:t.length>0?t.reduce(((e,t)=>e+t.clientY),0)/e.touches.length:e.clientY}}function getTouchPosition(e){return{x:e.clientX,y:e.clientY}}function getAllChildrenRecursive(e){let t=[];for(let o=0;o<e.children.length;o++){const n=e.children[o];t.push(n),t=t.concat(getAllChildrenRecursive(n))}return t}function isMobile(){let e=!1;var t;return t=navigator.userAgent||navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)))&&(e=!0),e}function isTouchCapable(){return"ontouchstart"in window||navigator.maxTouchPoints>0||navigator.msMaxTouchPoints>0}function downloadBlob(e,t="file.txt"){if(window.navigator&&window.navigator.msSaveOrOpenBlob)return window.navigator.msSaveOrOpenBlob(e);const o=window.URL.createObjectURL(e),n=document.createElement("a");n.href=o,n.download=t,n.dispatchEvent(new MouseEvent("click",{bubbles:!0,cancelable:!0,view:window})),setTimeout((()=>{window.URL.revokeObjectURL(o),n.remove()}),100)}function extentionToTag(e){return["png","jpg","jpeg","svg","gif","bmp","ico"].includes(e)?"img":["mp4","mov","avi","webm","mpeg"].includes(e)?"video":["mp3","wav","ogg","aac"].includes(e)?"audio":["pdf"].includes(e)?"embed":void 0}let slideUp=(e,t=500)=>{e.style.transitionProperty="height, margin, padding",e.style.transitionDuration=t+"ms",e.style.boxSizing="border-box",e.style.height=e.offsetHeight+"px",e.offsetHeight,e.style.overflow="hidden",e.style.height=0,e.style.paddingTop=0,e.style.paddingBottom=0,e.style.marginTop=0,e.style.marginBottom=0,window.setTimeout((async()=>{e.style.display="none",e.style.removeProperty("height"),e.style.removeProperty("padding-top"),e.style.removeProperty("padding-bottom"),e.style.removeProperty("margin-top"),e.style.removeProperty("margin-bottom"),e.style.removeProperty("overflow"),e.style.removeProperty("transition-duration"),e.style.removeProperty("transition-property")}),t)},slideUpAll=(e,t=500)=>{e.forEach((async e=>{e.style.transitionProperty="height, margin, padding",e.style.transitionDuration=t+"ms",e.style.boxSizing="border-box",e.style.height=e.offsetHeight+"px",e.offsetHeight,e.style.overflow="hidden",e.style.height=0,e.style.paddingTop=0,e.style.paddingBottom=0,e.style.marginTop=0,e.style.marginBottom=0})),window.setTimeout((async()=>{e.forEach((async e=>{e.style.display="none",e.style.removeProperty("height"),e.style.removeProperty("padding-top"),e.style.removeProperty("padding-bottom"),e.style.removeProperty("margin-top"),e.style.removeProperty("margin-bottom"),e.style.removeProperty("overflow"),e.style.removeProperty("transition-duration"),e.style.removeProperty("transition-property")}))}),t)},slideDown=(e,t=500)=>{e.style.removeProperty("display");let o=window.getComputedStyle(e).display;"none"===o&&(o="block"),e.style.display=o;let n=e.offsetHeight;e.style.overflow="hidden",e.style.height=0,e.style.paddingTop=0,e.style.paddingBottom=0,e.style.marginTop=0,e.style.marginBottom=0,e.offsetHeight,e.style.boxSizing="border-box",e.style.transitionProperty="height, margin, padding",e.style.transitionDuration=t+"ms",e.style.height=n+"px",e.style.removeProperty("padding-top"),e.style.removeProperty("padding-bottom"),e.style.removeProperty("margin-top"),e.style.removeProperty("margin-bottom"),window.setTimeout((async()=>{e.style.removeProperty("height"),e.style.removeProperty("overflow"),e.style.removeProperty("transition-duration"),e.style.removeProperty("transition-property")}),t)},slideDownAll=(e,t=500)=>{e.forEach((async e=>{e.style.removeProperty("display");let o=window.getComputedStyle(e).display;"none"===o&&(o="block"),e.style.display=o;let n=e.offsetHeight;e.style.overflow="hidden",e.style.height=0,e.style.paddingTop=0,e.style.paddingBottom=0,e.style.marginTop=0,e.style.marginBottom=0,e.offsetHeight,e.style.boxSizing="border-box",e.style.transitionProperty="height, margin, padding",e.style.transitionDuration=t+"ms",e.style.height=n+"px",e.style.removeProperty("padding-top"),e.style.removeProperty("padding-bottom"),e.style.removeProperty("margin-top"),e.style.removeProperty("margin-bottom")})),window.setTimeout((async()=>{e.forEach((async e=>{e.style.removeProperty("height"),e.style.removeProperty("overflow"),e.style.removeProperty("transition-duration"),e.style.removeProperty("transition-property")}))}),t)};var slideToggle=(e,t=500)=>"none"===window.getComputedStyle(e).display?slideDown(e,t):slideUp(e,t),slideToggleAll=(e,t=500)=>"none"===window.getComputedStyle(e[0]).display?slideDownAll(e,t):slideUpAll(e,t);let transferDocument=document.implementation.createHTMLDocument();async function loadDocument(e,t=!0,o=!0){let n=e.split("#"),i=n[0]??e;console.log("Loading document: "+i),loadingIcon.classList.toggle("shown",!0);let s,a=getViewBounds();if(loadingIcon.style.left=a.centerX-loadingIcon.offsetWidth/2+"px",loadingIcon.style.top=a.centerY-loadingIcon.offsetHeight/2+"px",documentContainer.classList.toggle("hide",!0),documentContainer.classList.toggle("show",!1),"phone"==deviceSize&&leftSidebar.collapse(!0),!isOffline){try{s=await fetch(i)}catch(e){return console.log("Cannot use fetch API (likely due to CORS), just loading the page normally."),void window.location.assign(i)}if(s.ok){setActiveDocument(i,o,t);let a=e.split(".").pop().split("?")[0].split("#")[0].toLowerCase().trim();if(documentType="none",embedType="none",customType="none","html"==a){let e=(await s.text()).replaceAll("<!DOCTYPE html>","").replaceAll("<html>","").replaceAll("</html>","");transferDocument.write(e);let t=document.importNode(transferDocument.querySelector(".document-container"),!0);documentContainer.remove(),documentContainer=t,webpageContainer.insertBefore(documentContainer,webpageContainer.children[1]),document.querySelector(".outline-tree").innerHTML=transferDocument.querySelector(".outline-tree").innerHTML;let o=n.length>1?n[1]:null;o&&document.getElementById(o).scrollIntoView(),setupRootPath(transferDocument),initializeDocumentTypes(),setTimeout((function(){initializePageEvents(documentContainer),initializePageEvents(document.querySelector(".outline-tree"))}),0),document.title=transferDocument.title,transferDocument.close()}else if(documentType="embed",embedType=extentionToTag(a),null!=embedType){let t=document.createElement(embedType);t.controls=!0,t.src=e,t.style.maxWidth="100%","embed"==embedType&&(t.style.width="100%",t.style.height="100%"),t.style.objectFit="contain",viewContent.innerHTML="",viewContent.setAttribute("class","view-content embed"),viewContent.appendChild(t),document.querySelector(".outline-tree").innerHTML="",document.title=e.split("/").pop()}else downloadBlob(await s.blob(),e.split("/").pop());await initializePage()}else setTimeout((function(){viewContent.innerHTML="\n\t\t\t<div>\n\t\t\t\t<center style='position: relative; transform: translateY(20vh); width: 100%; text-align: center;'>\n\t\t\t\t\t<h1 style>Page Not Found</h1>\n\t\t\t\t</center>\n\t\t\t</div>\n\t\t\t",document.querySelector(".outline-tree").innerHTML="",console.log("Page not found: "+getAbsoluteRootPath()+e);let t=getURLRootPath(getAbsoluteRootPath()+e);rootPath=t,document.querySelector("base").href=t,document.title="Page Not Found"}),1e3);return loadingIcon.classList.toggle("shown",!1),documentContainer.style.transitionDuration="",documentContainer.classList.toggle("hide",!1),documentContainer.classList.toggle("show",!0),transferDocument}setTimeout((function(){viewContent.innerHTML="\n<center style='position: relative; transform: translateY(20vh); width: 100%; text-align: center;'>\n\t<h1>You appear to be offline. Check your internet connection and then try reloading the page.</h1>\n</center>",document.querySelector(".outline-tree").innerHTML="",console.log("Page offline: "+getAbsoluteRootPath()+e);let t=getURLRootPath(getAbsoluteRootPath()+e);rootPath=t,document.querySelector("base").href=t,document.title="Page Offline",documentContainer.classList.toggle("hide",!1),documentContainer.classList.toggle("show",!0),loadingIcon.classList.toggle("shown",!1)}),1e3)}function setActiveDocument(e,t=!0,o=!0){let n=e.split("#")[0]??e;document.querySelector(".tree-item.mod-active")?.classList.remove("mod-active");let i,s=Array.from(document.querySelectorAll(".tree-item > .tree-item-contents > .tree-item-link"));for(let t of s)if(t.getAttribute("href")==decodeURI(e)){let e=t.parentElement.parentElement;for(e.classList.add("mod-active"),i=e;e.hasAttribute("data-depth");)setTreeCollapsed(e,!1,!1),e=e.parentElement.parentElement;break}if(t&&i?.scrollIntoView({block:"center",inline:"nearest"}),"undefined"!=typeof nodes&&window.renderWorker){let e=nodes?.paths.findIndex((function(e){return e.endsWith(n)}))??-1;e>=0&&(window.renderWorker.activeNode=e)}o&&"file:"!=window.location.protocol&&window.history.pushState({path:n},"",n)}function setupRootPath(e){let t=e.querySelector("#root-path").getAttribute("root-path");document.querySelector("base").href=t,document.querySelector("#root-path").setAttribute("root-path",t),rootPath=t}function getAbsoluteRootPath(){return"undefined"==typeof rootPath&&setupRootPath(document),new URL(window.location.href+"/../"+rootPath).pathname}function getURLPath(e=window.location.pathname){let t=getAbsoluteRootPath();return e.substring(t.length)}function getURLRootPath(e=window.location.pathname){let t=getURLPath(e).split("/"),o="";for(let e=0;e<t.length-1;e++)o+="../";return o}function setupHeaders(e){e.querySelectorAll(".heading-collapse-indicator").forEach((function(e){e.addEventListener("click",(function(){toggleTreeHeaderOpen(e.parentElement.parentElement,!0)}))})),e.querySelectorAll(".heading-wrapper").forEach((function(e){e.collapsed=!1,e.childrenContainer=e.querySelector(".heading-children"),e.parentHeader=e.parentElement.parentElement,e.headerElement=e.querySelector(".heading"),e.markdownPreviewSizer=getHeaderSizerEl(e),e.collapse=function(t,o=!0,n=!1){collapseHeader(e,t,o,n)},e.toggleCollapse=function(t=!0){toggleTreeHeaderOpen(e,t)},e.hide=function(){hideHeader(e)},e.show=function(t=!1,o=!1,n=!1){showHeader(e,t,o,n)}})),e.querySelectorAll(".heading").forEach((function(e){e.headingWrapper=e.parentElement}))}function isHeadingWrapper(e){return!!e&&e.classList.contains("heading-wrapper")}function getHeaderSizerEl(e){let t=e;for(;t&&!t.classList.contains("markdown-preview-sizer");)t=t.parentElement;return t||void 0}async function collapseHeader(e,t,o=!0,n=!1){let i=e.childrenContainer;if(o&&!t){let t=e.parentHeader;isHeadingWrapper(t)&&t.collapse(!1,!0,n)}if(e.classList.contains("is-collapsed")==t)return void(t||"canvas"!=documentType||e.show(!0));if(e.timeout&&(clearTimeout(e.timeout),i.style.transitionDuration="",i.style.height="",e.classList.toggle("is-animating",!1)),t){e.collapseHeight=i.offsetHeight+parseFloat(i.lastChild?.marginBottom||0);let t=e.nextElementSibling;for(;t&&"canvas"==documentType;){let e=t;isHeadingWrapper(e)&&e.show(!1,!0,!0),setTimeout((function(){e.forceShown=!1}),500),t=t.nextElementSibling}}let s=e.collapseHeight;if(i.style.height=s+"px",t||"canvas"!=documentType||e.show(!0),e.collapsed=t,n){console.log("instant"),i.style.transitionDuration="0s",e.classList.toggle("is-collapsed",t),i.style.height="",i.style.transitionDuration="";let o=Array.from(e.markdownPreviewSizer.children).reduce(((e,t)=>e+t.offsetHeight),0);return void(e.markdownPreviewSizer.style.minHeight=o+"px")}let a=getComputedStyle(i).transitionDuration;a=a.endsWith("s")?parseFloat(a):a.endsWith("ms")?parseFloat(a)/1e3:0;let l=Math.min(a*Math.sqrt(s)/16,.5);i.style.transitionDuration=`${l}s`,i.style.height=t?"0px":s+"px",e.classList.toggle("is-animating",!0),e.classList.toggle("is-collapsed",t),setTimeout((function(){i.style.transitionDuration="",t||(i.style.height=""),e.classList.toggle("is-animating",!1);let o=Array.from(e.markdownPreviewSizer.children).reduce(((e,t)=>e+t.offsetHeight),0);e.markdownPreviewSizer.style.minHeight=o+"px"}),1e3*l)}function toggleTreeHeaderOpen(e,t=!0){e.collapse(!e.collapsed,t)}function hideHeader(e){if(e.forceShown)return;if(e.classList.contains("is-hidden")||e.classList.contains("is-collapsed"))return;if("none"==getComputedStyle(e).display)return;let t=e.offsetHeight;e.classList.toggle("is-hidden",!0),0!=t&&(e.style.height=t+"px"),e.style.visibility="hidden"}function showHeader(e,t=!0,o=!1,n=!1){if(n&&(e.forceShown=!0),t){let t=e.parentHeader;isHeadingWrapper(t)&&t.show(!0,!1,n)}o&&e.querySelectorAll(".heading-wrapper").forEach((function(e){e.show(!1,!0,n)})),e.classList.contains("is-hidden")&&!e.classList.contains("is-collapsed")&&(e.classList.toggle("is-hidden",!1),e.style.height="",e.style.visibility="")}function setupTrees(e){const t=Array.from(e.querySelectorAll(".tree-container.file-tree .tree-item")),o=Array.from(e.querySelectorAll(".tree-container.outline-tree .tree-item"));e.querySelectorAll(".tree-item-link > .collapse-icon").forEach((function(e){e.addEventListener("click",(function(t){return t.preventDefault(),t.stopPropagation(),toggleTreeCollapsed(e.parentElement.parentElement.parentElement),!1}))})),e.querySelectorAll(".collapse-tree-button").forEach((function(e){e.treeRoot=e.parentElement.parentElement,e.icon=e.firstChild,e.icon.innerHTML="<path d></path><path d></path>";let n=e.treeRoot.classList.contains("file-tree")?t:o;e.setIcon=function(t){e.icon.children[0].setAttribute("d",t?collapseIconUp[0]:collapseIconDown[0]),e.icon.children[1].setAttribute("d",t?collapseIconUp[1]:collapseIconDown[1])},e.collapse=function(t){setTreeCollapsedAll(n,t),e.setIcon(t),e.collapsed=t},e.toggleCollapse=function(){e.collapse(!e.collapsed)},e.collapsed=0!=e.treeRoot.querySelectorAll(".tree-scroll-area + .tree-item.mod-collapsible.is-collapsed"),e.setIcon(e.collapsed),e.addEventListener("click",(function(t){return t.preventDefault(),t.stopPropagation(),e.toggleCollapse(),!1}))})),t.forEach((function(e){let t=e.querySelector(".tree-item-link");if(e.querySelector(".collapse-icon"))t?.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation();let t=this.parentElement?.parentElement;t&&toggleTreeCollapsed(t)}));else{let o=t.getAttribute("href").split(".").pop();if(!o.includes(" ")&&"html"!=o){let t=document.createElement("div");t.classList.add("nav-file-tag"),t.textContent=o.toUpperCase(),e.querySelector(".tree-item-contents").appendChild(t)}}}))}async function setTreeCollapsed(e,t,o=!0){if(!e||!e.classList.contains("mod-collapsible"))return;let n=e.querySelector(".tree-item-children");t?(e.classList.add("is-collapsed"),o?slideUp(n,100):n.style.display="none"):(e.classList.remove("is-collapsed"),o?slideDown(n,100):n.style.removeProperty("display"))}async function setTreeCollapsedAll(e,t,o=!0){let n=[];e.forEach((async e=>{if(!e||!e.classList.contains("mod-collapsible"))return;let o=e.querySelector(".tree-item-children");t?e.classList.add("is-collapsed"):e.classList.remove("is-collapsed"),n.push(o)})),t?o?slideUpAll(n,100):n.forEach((async e=>e.style.display="none")):o?slideDownAll(n,100):n.forEach((async e=>e.style.removeProperty("display")))}function toggleTreeCollapsed(e){e&&setTreeCollapsed(e,!e.classList.contains("is-collapsed"))}function toggleTreeCollapsedAll(e){e&&setTreeCollapsedAll(e,!e[0].classList.contains("is-collapsed"))}function setupCanvas(e){if("canvas"!=documentType||!e.querySelector(".canvas-wrapper"))return;e.querySelector(".canvas")?.setAttribute("style","translate: 0px 1px; scale: 1;");let t=getNodesBounds();function o(e){let t=e.touches??[];if(!(t.length>1)&&(1==e.button||0==e.button||t.length>0)){let o=getPointerPosition(e),n=!1,i=0,s=t.length,a=function(t){let a=t.touches??[],l=getPointerPosition(t);s!=a.length&&(o=l,s=a.length);let r=l.x-o.x,c=l.y-o.y,d=!1;if((1==e.button||1==a.length)&&focusedCanvasNode){let e=Math.abs(r)>Math.abs(1.5*c),t=Math.abs(c)>Math.abs(1.5*r),o=focusedCanvasNode.querySelector(".markdown-preview-sizer");if(o){let n=o.scrollHeight>o.parentElement.clientHeight+1,i=o.scrollWidth>o.parentElement.clientWidth+1;(e&&i||t&&n)&&(d=!0)}}if(d||(translateCanvas(r,c),o=l),2==a.length){let e=getPointerPosition(t,!1),o=getTouchPosition(t.touches[0]),s=getTouchPosition(t.touches[1]),a=Math.sqrt(Math.pow(o.x-s.x,2)+Math.pow(o.y-s.y,2));n||(n=!0,i=a),scaleCanvasAroundPoint(1+(a-i)/i,e.x,e.y),i=a}},l=function(e){document.body.removeEventListener("mousemove",a),document.body.removeEventListener("mouseup",l),document.body.removeEventListener("mouseenter",r),document.body.removeEventListener("touchmove",a),document.body.removeEventListener("touchend",l),document.body.removeEventListener("touchcancel",l)},r=function(e){1!=e.buttons&&4!=e.buttons&&l(e)};document.body.addEventListener("mousemove",a),document.body.addEventListener("mouseup",l),document.body.addEventListener("mouseenter",r),document.body.addEventListener("touchmove",a),document.body.addEventListener("touchend",l),document.body.addEventListener("touchcancel",l)}}setViewCenter(t.centerX,t.centerY),e.querySelectorAll(".canvas-node-container").forEach((function(e){var t=e.parentElement;function o(e){t.classList.toggle("is-focused"),null!=focusedCanvasNode&&focusedCanvasNode!=t&&(focusedCanvasNode.classList.remove("is-focused"),focusedCanvasNode.querySelector(".canvas-node-container").style.display=""),focusedCanvasNode=t,t.addEventListener("mouseleave",n),t.addEventListener("touchend",n)}function n(e){focusedCanvasNode&&(focusedCanvasNode.classList.remove("is-focused"),focusedCanvasNode=null),t.removeEventListener("mouseleave",n),t.removeEventListener("touchend",n)}e.addEventListener("mouseenter",o),e.addEventListener("touchstart",o)})),e.querySelectorAll(".canvas-node").forEach((function(e){e.addEventListener("dblclick",(function(t){fitViewToNode(e)}))})),e.querySelectorAll(".canvas-background").forEach((function(e){e.addEventListener("dblclick",(function(e){fitViewToCanvas()}))})),canvasWrapper.addEventListener("mousedown",o),canvasWrapper.addEventListener("touchstart",o);let n=0,i=0;canvasWrapper.addEventListener("mousemove",(function(e){let t=getPointerPosition(e);n=t.x,i=t.y}));let s=1,a=0,l=!1;canvasWrapper.addEventListener("wheel",(function(e){if(focusedCanvasNode){let e=focusedCanvasNode.querySelector(".markdown-preview-sizer");if(e&&e.scrollHeight>e.parentElement.clientHeight)return}if(e.preventDefault(),e.stopPropagation(),l){let t=1;t-=e.deltaY/700*t,t=clamp(t,.1,10);let o=getViewBounds();scaleCanvasAroundPoint(t,o.centerX,o.centerY)}else{let t=0==a;a-=e.deltaY/200;const o=.14*s;a=clamp(a,-o,o),t&&requestAnimationFrame(u)}}));let r=0,c=0,d=0;function u(e){if(r=e-c,0==c&&(r=30),c=e,d=.05*r+.95*d,d>50)return console.log("Scrolling too slow, turning on instant scroll"),void(l=!0);let t=s;s+=a*(r/1e3)*30,s=clamp(s,.1,10),getViewBounds(),scaleCanvasAroundPoint(s/t,n,i),a*=.4,Math.abs(a)<.01?(a=0,c=0):requestAnimationFrame(u)}fitViewToCanvas()}function getViewBounds(){let e=viewContent.getBoundingClientRect(),t=e.x,o=e.y,n=e.x+e.width,i=e.y+e.height;return{x:t,y:o,width:n-t,height:i-o,minX:t,minY:o,maxX:n,maxY:i,centerX:e.x+e.width/2,centerY:e.y+e.height/2}}function getNodesBounds(){let e=1/0,t=1/0,o=-1/0,n=-1/0;canvasNodes.forEach((function(i){let s=i.getBoundingClientRect();s.x<e&&(e=s.x),s.y<t&&(t=s.y),s.x+s.width>o&&(o=s.x+s.width),s.y+s.height>n&&(n=s.y+s.height)}));let i=o-e,s=n-t;return{x:e,y:t,width:i,height:s,minX:e,minY:t,maxX:o,maxY:n,centerX:e+i/2,centerY:t+s/2}}function getCanvasBounds(){let e=canvas.getBoundingClientRect(),t=e.x,o=e.y,n=e.width,i=e.height;return{x:t,y:o,width:n,height:i,minX:t,minY:o,maxX:t+n,maxY:o+i,centerX:e.x+e.width/2,centerY:e.y+e.height/2}}function scaleCanvasAroundPoint(e,t,o){let n=getCanvasBounds(),i=t-n.x,s=o-n.y,a=t-(n.x+i*e),l=o-(n.y+s*e);return scaleCanvas(e),translateCanvas(a,l),{x:a,y:l}}function scaleCanvas(e){let t=Math.max(e*canvas.style.scale,.001);canvas.style.scale=t,canvasWrapper.style.setProperty("--zoom-multiplier",1/Math.sqrt(t))}function translateCanvas(e,t){let o=canvas.style.translate,n=o.split(" "),i=n.length>0?parseFloat(o.split(" ")[0].trim()):0,s=n.length>1?parseFloat(o.split(" ")[1].trim()):i;canvas.style.translate=`${i+e}px ${s+t}px`}function setViewCenter(e,t){let o=getViewBounds();translateCanvas(o.centerX-e,o.centerY-t)}function getCanvasTranslation(){let e=canvas.style.translate,t=e.split(" "),o=t.length>0?parseFloat(e.split(" ")[0].trim()):0;return{x:o,y:t.length>1?parseFloat(e.split(" ")[1].trim()):o}}function scaleCanvasBackground(e){let t=e*canvasBackgroundPattern.getAttribute("width"),o=e*canvasBackgroundPattern.getAttribute("height");canvasBackgroundPattern.setAttribute("width",t),canvasBackgroundPattern.setAttribute("height",o)}function translateCanvasBackground(e,t){canvasBackgroundPattern.setAttribute("x",e+canvasBackgroundPattern.getAttribute("x")),canvasBackgroundPattern.setAttribute("y",t+canvasBackgroundPattern.getAttribute("y"))}function fitViewToNode(e){let t=getElBounds(e),o=getViewBounds(),n=getCanvasBounds(),i=.8*Math.min(o.width/t.width,o.height/t.height),s=n.x,a=n.y,l=s+(t.centerX-s)*i,r=a+(t.centerY-a)*i,c=o.centerX-l,d=o.centerY-r;t=getElBounds(e),canvas.style.transition="scale 0.5s cubic-bezier(0.5, -0.1, 0.5, 1.1), translate 0.5s cubic-bezier(0.5, -0.1, 0.5, 1.1)",scaleCanvas(i),translateCanvas(c,d),setTimeout((function(){canvas.style.transition=""}),550)}function fitViewToCanvas(){let e=getNodesBounds(),t=getViewBounds(),o=getCanvasBounds(),n=.8*Math.min(t.width/e.width,t.height/e.height),i=o.x,s=o.y,a=i+(e.centerX-i)*n,l=s+(e.centerY-s)*n,r=t.centerX-a,c=t.centerY-l;canvas.style.transition="scale 0.5s cubic-bezier(0.5, -0.1, 0.5, 1.1), translate 0.5s cubic-bezier(0.5, -0.1, 0.5, 1.1)",scaleCanvas(n),translateCanvas(r,c),setTimeout((function(){canvas.style.transition=""}),550)}function setupCallouts(e){e.querySelectorAll(".callout.is-collapsible .callout-title").forEach((function(e){e.addEventListener("click",(function(){var t=this.parentElement;t.classList.toggle("is-collapsed"),e.querySelector(".callout-fold").classList.toggle("is-collapsed"),slideToggle(t.querySelector(".callout-content"),100)}))}))}function setupCheckboxes(e){e.querySelectorAll(".task-list-item-checkbox").forEach((function(e){e.addEventListener("click",(function(){var e=this.parentElement;e.classList.toggle("is-checked"),e.setAttribute("data-task",e.classList.contains("is-checked")?"x":" ")}))})),e.querySelectorAll('.plugin-tasks-list-item input[type="checkbox"]').forEach((function(e){e.checked=e.parentElement.classList.contains("is-checked")})),e.querySelectorAll(".kanban-plugin__item.is-complete").forEach((function(e){e.querySelector('input[type="checkbox"]').checked=!0}))}function setupCodeblocks(e){e.querySelectorAll(".copy-code-button").forEach((function(t){t.addEventListener("click",(function(){var t=this.parentElement.querySelector("code").textContent;navigator.clipboard.writeText(t),this.textContent="Copied!",setTimeout((function(){e.querySelectorAll(".copy-code-button").forEach((function(e){e.textContent="Copy"}))}),2e3)}))}))}function setupLinks(e){e.querySelectorAll(".internal-link, .footnote-link, .tree-item:not(.mod-tree-folder) > .tree-item-contents > .tree-item-link").forEach((function(e){e.addEventListener("click",(function(t){let o=e.getAttribute("href");if(t.preventDefault(),o)if(o.startsWith("#")){let e=document.getElementById(o.substring(1));e?(e.headingWrapper?.collapse(!1,!0,!0),setTimeout((function(){e.classList.contains(".heading")?e.headingWrapper?.scrollIntoView({behavior:"smooth",block:"start"}):e.scrollIntoView({behavior:"smooth",block:"start"}),"phone"==deviceSize&&rightSidebar.collapse(!0)}),0)):console.log("No element found with id: "+o.substring(1))}else loadDocument(o,!0,!e.classList.contains("tree-item-link"))}))}))}function setupSidebars(){sidebarCollapseIcons[0].otherIcon=sidebarCollapseIcons[1],sidebarCollapseIcons[1].otherIcon=sidebarCollapseIcons[0],sidebarCollapseIcons[0].gutter=sidebarGutters[0],sidebarCollapseIcons[1].gutter=sidebarGutters[1],sidebarCollapseIcons[0].sidebar=sidebars[0],sidebarCollapseIcons[1].sidebar=sidebars[1],sidebarGutters[0].otherGutter=sidebarGutters[1],sidebarGutters[1].otherGutter=sidebarGutters[0],sidebarGutters[0].collapseIcon=sidebarCollapseIcons[0],sidebarGutters[1].collapseIcon=sidebarCollapseIcons[1],sidebars[0].otherSidebar=sidebars[1],sidebars[1].otherSidebar=sidebars[0],sidebars[0].gutter=sidebarGutters[0],sidebars[1].gutter=sidebarGutters[1],sidebars.forEach((function(e){e.collapsed=e.classList.contains("is-collapsed"),e.collapse=function(t=!0){!t&&this.temporarilyCollapsed&&"large-screen"==deviceSize&&this.gutter.collapse(!0),!t&&document.body.classList.contains("floating-sidebars")&&document.body.addEventListener("click",(function t(o){e.collapse(!0),document.body.removeEventListener("click",t)})),"phone"==deviceSize&&(t||e.otherSidebar.fullCollapse(!0,!0),t&&e.gutter.otherGutter.collapse(!1,!0)),"tablet"==deviceSize&&(t||e.otherSidebar.collapse(!0)),this.classList.toggle("is-collapsed",t),this.collapsed=t},e.temporaryCollapse=function(e=!0){this.temporarilyCollapsed=!0,this.collapse(!0),this.gutter.collapse(!1),this.collapsed=e},e.fullCollapse=function(e=!0,t=!1){this.collapse(e),this.gutter.collapse(!0,t),this.collapsed=e},e.toggleCollapse=function(){this.collapse(!this.collapsed)},e.toggleFullCollapse=function(){this.fullCollapse(!this.collapsed)}})),sidebarGutters.forEach((function(e){e.collapsed=e.classList.contains("is-collapsed"),e.collapse=function(e,t=!1){!t&&document.body.classList.contains("sidebars-always-collapsible")||(this.classList.toggle("is-collapsed",e),this.collapsed=e)},e.toggleCollapse=function(){this.collapse(!this.collapsed)}})),sidebarCollapseIcons.forEach((function(e){e.addEventListener("click",(function(t){t.stopPropagation(),e.sidebar.toggleCollapse()}))})),document.querySelectorAll(".sidebar-container").forEach((function(e){e.addEventListener("click",(function(e){e.stopPropagation()}))}))}function getSidebarWidthProp(){return getComputedPixelValue("--sidebar-width")}function setupThemeToggle(){function e(e,t=!1){let o=document.querySelector(".theme-toggle-input");if(o.checked=e,t){var n=document.body.style.transition;document.body.style.transition="none"}!o.classList.contains("is-checked")&&e?o.classList.add("is-checked"):o.classList.contains("is-checked")&&!e&&o.classList.remove("is-checked"),e?(document.body.classList.contains("theme-dark")&&document.body.classList.remove("theme-dark"),document.body.classList.contains("theme-light")||document.body.classList.add("theme-light")):(document.body.classList.contains("theme-light")&&document.body.classList.remove("theme-light"),document.body.classList.contains("theme-dark")||document.body.classList.add("theme-dark")),t&&setTimeout((function(){document.body.style.transition=n}),100),localStorage.setItem("theme_toggle",e?"true":"false")}null!=localStorage.getItem("theme_toggle")&&e("true"==localStorage.getItem("theme_toggle")),document.body.classList.contains("theme-light")?e(!0):e(!1),document.querySelector(".theme-toggle-input")?.addEventListener("change",(t=>{console.log("Theme toggle changed to: "+!("true"==localStorage.getItem("theme_toggle"))),e(!("true"==localStorage.getItem("theme_toggle")))}))}function setupScroll(e){if("canvas"!=documentType)return;let t=Array.from(e.querySelectorAll(".markdown-preview-view")),o=0,n=0;t.forEach((async function(e){console.log("Setting up markdown view");let t=Array.from(e.querySelectorAll(".heading-wrapper"));e.updateVisibleWindowMarkdown=function(o=!0,i=!0){let s=e.getBoundingClientRect();n=Math.min(.1*s.height,150);let a=s.top-n,l=s.bottom+n;async function r(e){let t=e?.getBoundingClientRect();if(!t)return;let n=t.top<a&&t.bottom<a||t.top>l&&t.bottom>l;n&&o?e.hide():!n&&i&&e.show()}for(let e=0;e<t.length;e++){let o=t[e];o&&r(o)}};let o=0;e.addEventListener("scroll",(function(){Math.abs(e.scrollTop-o)>n/3&&e.updateVisibleWindowMarkdown(!1,!0),o=e.scrollTop}))})),setInterval((async function(){t.length>0&&(t[o].updateVisibleWindowMarkdown(),o=(o+1)%t.length)}),200)}function setupExcalidraw(e){e.querySelectorAll(".excalidraw-svg svg").forEach((function(e){let t=e.querySelector("rect").getAttribute("fill")>"#7F7F7F";e.classList.add(t?"light":"dark")}))}</script><script>let nodes={paths:["编程/c++/访问类的私有成员和方法.html","编程/c++/c++.html","编程/编程.html","渲染相关/其他/色彩/色彩.html","渲染相关/其他/色彩/色彩空间、hdr和aces.html","渲染相关/其他/其他.html","渲染相关/其他/字体“大小”.html","渲染相关/图形api/opengl/opengl.html","渲染相关/图形api/opengl/opengl踩坑实录.html","渲染相关/图形api/vulkan/imgui文字渲染.html","渲染相关/图形api/vulkan/imgui中使用vulkan渲染窗口.html","渲染相关/图形api/vulkan/vulkan.html","渲染相关/图形api/vulkan/vulkan的setup.html","渲染相关/图形api/图形api.html","渲染相关/渲染相关.html","引擎/ue4/blue-print/材质.html","引擎/ue4/blue-print/跨蓝图.html","引擎/ue4/blue-print/粒子.html","引擎/ue4/blue-print/时间和动画.html","引擎/ue4/blue-print/blue-print.html","引擎/ue4/blue-print/construct-script和event-graph.html","引擎/ue4/niagara/坑.html","引擎/ue4/niagara/其他.html","引擎/ue4/niagara/指令数优化.html","引擎/ue4/niagara/houdini-for-niagara.html","引擎/ue4/niagara/niagara.html","引擎/ue4/niagara/niagara-module.html","引擎/ue4/niagara/niagara-render.html","引擎/ue4/niagara/niagara-ribbon.html","引擎/ue4/niagara/niagara-spawn.html","引擎/ue4/niagara/simulation-stages.html","引擎/ue4/trouble-shooting/透明物体间的排序问题.html","引擎/ue4/trouble-shooting/trouble-shooting.html","引擎/ue4/ue4.html","引擎/引擎.html","dcc/ae插件/变量/变量.html","dcc/ae插件/变量/值.html","dcc/ae插件/变量/ui.html","dcc/ae插件/坑.html","dcc/ae插件/ae插件.html","dcc/dcc.html","houdini-toolset/安装配置/安装.html","houdini-toolset/安装配置/安装配置.html","houdini-toolset/功能/菜单功能/变量右键菜单.html","houdini-toolset/功能/菜单功能/菜单功能.html","houdini-toolset/功能/菜单功能/节点右键菜单.html","houdini-toolset/功能/菜单功能/主菜单.html","houdini-toolset/功能/代码库.html","houdini-toolset/功能/功能.html","houdini-toolset/功能/快速命令.html","houdini-toolset/功能/移动&复制节点连接.html","houdini-toolset/功能/houdini节点.html","houdini-toolset/简介.html","houdini-toolset/houdini-toolset.html","index.html"],nodeCount:55,linkSources:[52,52,52,52,52,52,52,52],linkTargets:[41,51,49,46,45,43,50,47],labels:["访问类的私有成员和方法","C++","编程","色彩","色彩空间、HDR和ACES","其他","字体“大小”","OpenGL","OpenGL踩坑实录","ImGui文字渲染","ImGui中使用Vulkan渲染窗口","Vulkan","Vulkan的Setup","图形API","渲染相关","材质","跨蓝图","粒子","时间和动画","Blue Print","Construct Script和Event Graph","坑","其他","指令数优化","Houdini For Niagara","Niagara","Niagara Module","Niagara Render","Niagara Ribbon","Niagara Spawn","Simulation Stages","透明物体间的排序问题","Trouble Shooting","UE4","引擎","变量","值","UI","坑","AE插件","DCC","安装","安装配置","变量右键菜单","菜单功能","节点右键菜单","主菜单","代码库","功能","快速命令","移动&复制节点连接","Houdini节点","简介","Houdini-Toolset","Index"],radii:[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4.15234375,3,4.15234375,3,4.15234375,4.15234375,4.15234375,3,4.15234375,4.15234375,4.15234375,7,3,3],linkCount:8},attractionForce=1,linkLength=10,repulsionForce=150,centralForce=3,edgePruning=100</script></head><body class="theme-dark loading"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-container"><div class="sidebar-sizer"><div class="sidebar-content-positioner"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Notebook</span><button class="clickable-icon collapse-tree-button is-collapsed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">编程</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">C++</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="编程/c++/访问类的私有成员和方法.html"><span class="tree-item-title">访问类的私有成员和方法</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="编程/c++/c++.html"><span class="tree-item-title">C++</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="编程/编程.html"><span class="tree-item-title">编程</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">渲染相关</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">其他</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">色彩</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/其他/色彩/色彩.html"><span class="tree-item-title">色彩</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/其他/色彩/色彩空间.xmind"><span class="tree-item-title">色彩空间</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/其他/色彩/色彩空间.vsdx"><span class="tree-item-title">色彩空间</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/其他/色彩/色彩空间、hdr和aces.html"><span class="tree-item-title">色彩空间、HDR和ACES</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/其他/其他.html"><span class="tree-item-title">其他</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/其他/字体“大小”.html"><span class="tree-item-title">字体“大小”</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">图形API</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">OpenGL</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/图形api/opengl/opengl.html"><span class="tree-item-title">OpenGL</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/图形api/opengl/opengl踩坑实录.html"><span class="tree-item-title">OpenGL踩坑实录</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Vulkan</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/图形api/vulkan/imgui文字渲染.html"><span class="tree-item-title">ImGui文字渲染</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/图形api/vulkan/imgui中使用vulkan渲染窗口.html"><span class="tree-item-title">ImGui中使用Vulkan渲染窗口</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/图形api/vulkan/vulkan.html"><span class="tree-item-title">Vulkan</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/图形api/vulkan/vulkan的setup.html"><span class="tree-item-title">Vulkan的Setup</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/图形api/图形api.html"><span class="tree-item-title">图形API</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="渲染相关/渲染相关.html"><span class="tree-item-title">渲染相关</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">引擎</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">UE4</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Blue Print</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/blue-print/材质.html"><span class="tree-item-title">材质</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/blue-print/跨蓝图.html"><span class="tree-item-title">跨蓝图</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/blue-print/粒子.html"><span class="tree-item-title">粒子</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/blue-print/时间和动画.html"><span class="tree-item-title">时间和动画</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/blue-print/blue-print.html"><span class="tree-item-title">Blue Print</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/blue-print/construct-script和event-graph.html"><span class="tree-item-title">Construct Script和Event Graph</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Niagara</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/niagara/坑.html"><span class="tree-item-title">坑</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/niagara/其他.html"><span class="tree-item-title">其他</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/niagara/指令数优化.html"><span class="tree-item-title">指令数优化</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/niagara/houdini-for-niagara.html"><span class="tree-item-title">Houdini For Niagara</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/niagara/niagara.html"><span class="tree-item-title">Niagara</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/niagara/niagara-module.html"><span class="tree-item-title">Niagara Module</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/niagara/niagara-render.html"><span class="tree-item-title">Niagara Render</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/niagara/niagara-ribbon.html"><span class="tree-item-title">Niagara Ribbon</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/niagara/niagara-spawn.html"><span class="tree-item-title">Niagara Spawn</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/niagara/simulation-stages.html"><span class="tree-item-title">Simulation Stages</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Trouble Shooting</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/trouble-shooting/透明物体间的排序问题.html"><span class="tree-item-title">透明物体间的排序问题</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/trouble-shooting/trouble-shooting.html"><span class="tree-item-title">Trouble Shooting</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/ue4/ue4.html"><span class="tree-item-title">UE4</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="引擎/引擎.html"><span class="tree-item-title">引擎</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">DCC</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">AE插件</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">变量</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="dcc/ae插件/变量/变量.html"><span class="tree-item-title">变量</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="dcc/ae插件/变量/值.html"><span class="tree-item-title">值</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="dcc/ae插件/变量/ui.html"><span class="tree-item-title">UI</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="dcc/ae插件/坑.html"><span class="tree-item-title">坑</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="dcc/ae插件/ae插件.html"><span class="tree-item-title">AE插件</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="dcc/dcc.html"><span class="tree-item-title">DCC</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Houdini-Toolset</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">安装配置</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/安装配置/安装.html"><span class="tree-item-title">安装</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/安装配置/安装配置.html"><span class="tree-item-title">安装配置</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">功能</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">菜单功能</span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/功能/菜单功能/变量右键菜单.html"><span class="tree-item-title">变量右键菜单</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/功能/菜单功能/菜单功能.html"><span class="tree-item-title">菜单功能</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/功能/菜单功能/节点右键菜单.html"><span class="tree-item-title">节点右键菜单</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/功能/菜单功能/主菜单.html"><span class="tree-item-title">主菜单</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/功能/代码库.html"><span class="tree-item-title">代码库</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/功能/功能.html"><span class="tree-item-title">功能</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/功能/快速命令.html"><span class="tree-item-title">快速命令</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/功能/移动&amp;复制节点连接.html"><span class="tree-item-title">移动&amp;复制节点连接</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/功能/houdini节点.html"><span class="tree-item-title">Houdini节点</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/简介.html"><span class="tree-item-title">简介</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="houdini-toolset/houdini-toolset.html"><span class="tree-item-title">Houdini-Toolset</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="index.html"><span class="tree-item-title">Index</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div><div class="sidebar-gutter"><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div></div><div class="document-container show"><div class="markdown-preview-view markdown-rendered node-insert-event is-readable-line-width allow-fold-headings show-indentation-guide allow-fold-lists show-properties" style="tab-size:4"><style id="MJX-CHTML-styles">mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-msup{display:inline-block;text-align:left}mjx-mn{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("https://publish.obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff") format("woff")}mjx-c.mjx-c1D442.TEX-I::before{padding:.704em .763em .022em 0;content:"O"}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c1D446.TEX-I::before{padding:.705em .645em .022em 0;content:"S"}mjx-c.mjx-c1D435.TEX-I::before{padding:.683em .759em 0 0;content:"B"}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}mjx-c.mjx-c1D441.TEX-I::before{padding:.683em .888em 0 0;content:"N"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}</style><div class="markdown-preview-sizer markdown-preview-section" style="min-height:2417px"><div class="markdown-preview-pusher" style="width:1px;height:.1px;margin-bottom:0"></div><div class="mod-header"></div><div class="heading-wrapper"><h1 data-heading="ImGui中Vulkan的窗口渲染" class="heading" id="ImGui中Vulkan的窗口渲染"><div class="heading-before"></div>ImGui中Vulkan的窗口渲染<div class="heading-after">...</div></h1><div class="heading-children"><div><p>先看看ImGui中的Vulkan窗口结构体：</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">struct ImGui_ImplVulkanH_Window
{
    int                 Width;
    int                 Height;
    VkSwapchainKHR      Swapchain;
    VkSurfaceKHR        Surface;
    VkSurfaceFormatKHR  SurfaceFormat;
    VkPresentModeKHR    PresentMode;
    VkRenderPass        RenderPass;
    VkPipeline          Pipeline;               // The window pipeline may uses a different VkRenderPass than the one passed in ImGui_ImplVulkan_InitInfo
    bool                ClearEnable;
    VkClearValue        ClearValue;
    uint32_t            FrameIndex;             // Current frame being rendered to (0 &lt;= FrameIndex &lt; FrameInFlightCount)
    uint32_t            ImageCount;             // Number of simultaneous in-flight frames (returned by vkGetSwapchainImagesKHR, usually derived from min_image_count)
    uint32_t            SemaphoreIndex;         // Current set of swapchain wait semaphores we're using (needs to be distinct from per frame data)
    ImGui_ImplVulkanH_Frame*            Frames;
    ImGui_ImplVulkanH_FrameSemaphores*  FrameSemaphores;

    ImGui_ImplVulkanH_Window()
    {
        memset((void*)this, 0, sizeof(*this));
        PresentMode = (VkPresentModeKHR)~0;     // Ensure we get an error if user doesn't set this.
        ClearEnable = true;
    }
};
</code><button class="copy-code-button">复制</button></pre></div><div><p>后文所做的事情无非就是把这个结构体填充完毕。</p></div><div class="heading-wrapper"><h2 data-heading="Setup Vulkan" class="heading" id="Setup_Vulkan"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Setup Vulkan<div class="heading-after">...</div></h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="首先先声明一下后面会使用的变量" class="heading" id="首先先声明一下后面会使用的变量"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>首先先声明一下后面会使用的变量<div class="heading-after">...</div></h3><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">static VkAllocationCallbacks* g_Allocator = NULL;
static VkInstance               g_Instance = VK_NULL_HANDLE;
static VkPhysicalDevice         g_PhysicalDevice = VK_NULL_HANDLE;
static VkDevice                 g_Device = VK_NULL_HANDLE;
static uint32_t                 g_QueueFamily = (uint32_t)-1;
static VkQueue                  g_Queue = VK_NULL_HANDLE;
static VkDebugReportCallbackEXT g_DebugReport = VK_NULL_HANDLE;
static VkPipelineCache          g_PipelineCache = VK_NULL_HANDLE;
static VkDescriptorPool         g_DescriptorPool = VK_NULL_HANDLE;

static ImGui_ImplVulkanH_Window g_MainWindowData;// 这是imgui用来控制vulkan渲染到窗口的
static int                      g_MinImageCount = 2;
static bool                     g_SwapChainRebuild = false;
</code><button class="copy-code-button">复制</button></pre></div><div><p>然后按顺序执行下列步骤。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="创建Vulkan Instance" class="heading" id="创建Vulkan_Instance"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建Vulkan Instance<div class="heading-after">...</div></h3><div class="heading-children"><div><p>官方教程说Vulkan Instance维护了每个Vulkan应用的状态，因此必须先进行vulkan instance的创建。<a data-tooltip-position="top" aria-label="https://blog.csdn.net/Bleach3/article/details/105821759" rel="noopener" class="external-link" href="https://blog.csdn.net/Bleach3/article/details/105821759" target="_blank">此文章</a>也说明了vulkan instance的初始化过程中会加载并初始化GPU驱动。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkInstanceCreateInfo create_info = {};
create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
create_info.enabledExtensionCount = extensions_count;
create_info.ppEnabledExtensionNames = extensions;
err = vkCreateInstance(&amp;create_info, g_Allocator, &amp;g_Instance);
</code><button class="copy-code-button">复制</button></pre></div><div><p>在退出应用时需要自行销毁此instance。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="获取GPU设备" class="heading" id="获取GPU设备"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>获取GPU设备<div class="heading-after">...</div></h3><div class="heading-children"><div><p>下列代码只是获取了GPU设备信息之后选择了一个GPU设备作为此引用的vulkan设备，并把设备信息储存起来，没有进行其他操作。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">uint32_t gpu_count;
err = vkEnumeratePhysicalDevices(g_Instance, &amp;gpu_count, NULL);
check_vk_result(err);
IM_ASSERT(gpu_count &gt; 0);

VkPhysicalDevice* gpus = (VkPhysicalDevice*)malloc(sizeof(VkPhysicalDevice) * gpu_count);
err = vkEnumeratePhysicalDevices(g_Instance, &amp;gpu_count, gpus);
check_vk_result(err);

// If a number &gt;1 of GPUs got reported, find discrete GPU if present, or use first one available. This covers
// most common cases (multi-gpu/integrated+dedicated graphics). Handling more complicated setups (multiple
// dedicated GPUs) is out of scope of this sample.
// 这里优先选择独显，如无独显则选择获取的第一个GPU设备
int use_gpu = 0;
for (int i = 0; i &lt; (int)gpu_count; i++)
{
    VkPhysicalDeviceProperties properties;
    vkGetPhysicalDeviceProperties(gpus[i], &amp;properties);
    if (properties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU)
    {
        use_gpu = i;
        break;
    }
}

g_PhysicalDevice = gpus[use_gpu];
free(gpus);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h3 data-heading="选择队列族" class="heading" id="选择队列族"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>选择队列族<div class="heading-after">...</div></h3><div class="heading-children"><div><blockquote><p>[Vulkan 的几乎所有操作，从绘制到加载纹理都需要将操作 指令提交给一个队列，然后才能执行。Vulkan 有多种不同类型的队列，它们属于不同的队列族，每个队列族的队列只允许执行特定的一部分指令。 比如，可能存在只允许执行计算相关指令的队列族和只允许执行内存传输的队列族。](<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/460921731" rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/460921731" target="_blank">Vulkan从入门到精通31-队列族和逻辑设备 - 知乎 (zhihu.com)</a>)</p></blockquote></div><div><blockquote><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">uint32_t count;
vkGetPhysicalDeviceQueueFamilyProperties(g_PhysicalDevice, &amp;count, NULL);
VkQueueFamilyProperties* queues = (VkQueueFamilyProperties*)malloc(sizeof(VkQueueFamilyProperties) * count);
vkGetPhysicalDeviceQueueFamilyProperties(g_PhysicalDevice, &amp;count, queues);
for (uint32_t i = 0; i &lt; count; i++)
    if (queues[i].queueFlags &amp; VK_QUEUE_GRAPHICS_BIT)
    {
        g_QueueFamily = i;
        break;
    }
free(queues);
IM_ASSERT(g_QueueFamily != (uint32_t)-1);
</code><button class="copy-code-button">复制</button></pre></blockquote></div></div></div><div class="heading-wrapper"><h3 data-heading="创建逻辑设备" class="heading" id="创建逻辑设备"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建逻辑设备<div class="heading-after">...</div></h3><div class="heading-children"><div><p>创建逻辑设备时需要传入queue的参数，因此需要先创建queue info才能创建设备。在创建设备时也会创建queue。<br>逻辑设备肯定就区别于物理设备，之后需要vulkan进行交互的都是逻辑设备。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">int device_extension_count = 1;
const char* device_extensions[] = { "VK_KHR_swapchain" };
const float queue_priority[] = { 1.0f };
VkDeviceQueueCreateInfo queue_info[1] = {};
queue_info[0].sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
queue_info[0].queueFamilyIndex = g_QueueFamily;
queue_info[0].queueCount = 1;
queue_info[0].pQueuePriorities = queue_priority;
VkDeviceCreateInfo create_info = {};
create_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
create_info.queueCreateInfoCount = sizeof(queue_info) / sizeof(queue_info[0]);
create_info.pQueueCreateInfos = queue_info;
create_info.enabledExtensionCount = device_extension_count;
create_info.ppEnabledExtensionNames = device_extensions;
err = vkCreateDevice(g_PhysicalDevice, &amp;create_info, g_Allocator, &amp;g_Device);
check_vk_result(err);
vkGetDeviceQueue(g_Device, g_QueueFamily, 0, &amp;g_Queue);
</code><button class="copy-code-button">复制</button></pre></div><div><p>同样地，在程序退出时需要调用kDestroyDevice。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="创建描述符池" class="heading" id="创建描述符池"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建描述符池<div class="heading-after">...</div></h3><div class="heading-children"><div><p>在vulkan中，descriptor大概是着色器使用的变量，最终组成discriptor set之后才能被shader使用。<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/450434645" rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/450434645" target="_blank">这篇文章</a>对descriptor解释得蛮清楚。</p></div><div><p><img alt="v2-61ccfca7561dc80ff9e2cebfeaa446e3_1440w" src="app://4f89245e4b0fbc8f4c3f1bbebd389eecada3/C:/%5CUsers%5CMECHREV%5CDownloads%5Cv2-61ccfca7561dc80ff9e2cebfeaa446e3_1440w.jpg" referrerpolicy="no-referrer"></p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkDescriptorPoolSize pool_sizes[] =
{
    { VK_DESCRIPTOR_TYPE_SAMPLER, 1000 },
    { VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1000 },
    { VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1000 },
    { VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1000 },
    { VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, 1000 },
    { VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, 1000 },
    { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1000 },
    { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1000 },
    { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 1000 },
    { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, 1000 },
    { VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 1000 }
};
VkDescriptorPoolCreateInfo pool_info = {};
pool_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
pool_info.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
pool_info.maxSets = 1000 * IM_ARRAYSIZE(pool_sizes);
pool_info.poolSizeCount = (uint32_t)IM_ARRAYSIZE(pool_sizes);
pool_info.pPoolSizes = pool_sizes;
err = vkCreateDescriptorPool(g_Device, &amp;pool_info, g_Allocator, &amp;g_DescriptorPool);
check_vk_result(err);
</code><button class="copy-code-button">复制</button></pre></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="创建SwapChain" class="heading" id="创建SwapChain"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建SwapChain<div class="heading-after">...</div></h2><div class="heading-children"><div><p>首先要使用某些方法创建窗口。</p></div><div><p>以GLFW为例，可以先用其创建一个窗口。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">if (!glfwInit())
    return 1;

glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
GLFWwindow* window = glfwCreateWindow(1920, 1080, "Doxel", NULL, NULL);
</code><button class="copy-code-button">复制</button></pre></div><div><p>接下来就是vulkan时间。</p></div><div class="heading-wrapper"><h3 data-heading="预先准备" class="heading" id="预先准备"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>预先准备<div class="heading-after">...</div></h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="创建surface" class="heading" id="创建surface"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建surface<div class="heading-after">...</div></h4><div class="heading-children"><div><p>vulkan中有WSI(Window Surface Intergration)的概念，也就是将vulkan渲染的结果显示在某个window上。</p></div><div><p>surface的创建方法如下：</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkSurfaceKHR surface;
glfwCreateWindowSurface(g_Instance, window, g_Allocator, &amp;surface);
</code><button class="copy-code-button">复制</button></pre></div><div><p>最终会进行如下过程。</p></div><div><p>vkGetInstanceProcAddr(instance, "vkCreateWin32SurfaceKHR");这个函数似乎是用来获取指定instance中的vkCreateWin32SurfaceKHR函数地址，主要是为了节省时间优化效率，没什么功能上的意义。[<a data-tooltip-position="top" aria-label="https://www.jianshu.com/p/b19704d966a8" rel="noopener" class="external-link" href="https://www.jianshu.com/p/b19704d966a8" target="_blank">参考</a>]</p></div><div><p>在创建的时候获取了GLFW之前创建的窗口的Windows的handle，而后此handle会记录在VkWin32SurfaceCreateInfoKHR结构体内，然后使用vkCreateWin32SurfaceKHR创建Surface。</p></div></div></div><div class="heading-wrapper"><h4 data-heading="创建色彩空间和图像(像素)格式" class="heading" id="创建色彩空间和图像(像素)格式"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建色彩空间和图像(像素)格式<div class="heading-after">...</div></h4><div class="heading-children"><div><p>而后创建色彩空间和格式信息。下面的imgui函数封装了访问和匹配vulkan设备支持的格式信息，返回的是VkSurfaceFormatKHR类型值，此类型由色彩空间和格式组成。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">const VkFormat requestSurfaceImageFormat[] = { VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_B8G8R8_UNORM, VK_FORMAT_R8G8B8_UNORM };
const VkColorSpaceKHR requestSurfaceColorSpace = VK_COLORSPACE_SRGB_NONLINEAR_KHR;
wd-&gt;SurfaceFormat = ImGui_ImplVulkanH_SelectSurfaceFormat(g_PhysicalDevice, wd-&gt;Surface, requestSurfaceImageFormat, (size_t)IM_ARRAYSIZE(requestSurfaceImageFormat), requestSurfaceColorSpace);

</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="创建呈现模式信息" class="heading" id="创建呈现模式信息"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建呈现模式信息<div class="heading-after">...</div></h4><div class="heading-children"><div><p>呈现模式主要控制了，在渲染出一个图像后，采用什么策略显示到屏幕。各个策略如下，fifo策略在帧数拉满时没有画面撕裂。</p></div><div><ul><li data-line="0"><p>VK_PRESENT_MODE_IMMEDIATE_KHR：你的程序提交的图像会立即传输到屏幕，这可能会导致撕裂；</p></li><li data-line="2"><p>VK_PRESENT_MODE_FIFO_KHR：交换链是个队列，显示的时候从队列头拿一个图像，程序插入渲染的图像到队列尾。如果队列满了程序就要等待，这差不多像是垂直同步，显示刷新的时刻就是垂直空白；</p></li><li data-line="4"><p>VK_PRESENT_MODE_FIFO_RELAXED_KHR：在最后一个垂直空白的时候，如果应用迟到，且队列为空，该模式才会和前面的那个有所不同。这样就不等到下一个垂直空白，图像会直接传输到屏幕，可能导致撕裂；</p></li><li data-line="6"><p>VK_PRESENT_MODE_MAILBOX_KHR：这是第二个模式的又一个变种，当队列满的时候，它不会阻塞应用，已经在队列中的图像会被新的替换。这个模式可以实现三重缓冲，避免撕裂，比使用双重缓冲的垂直同步减少很多延迟。</p></li></ul></div><div><p>很显然，下列代码中的imgui函数也是封装了访问和匹配vulkan设备显示方法。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">#ifdef IMGUI_UNLIMITED_FRAME_RATE
    VkPresentModeKHR present_modes[] = { VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_IMMEDIATE_KHR, VK_PRESENT_MODE_FIFO_KHR };
#else
    VkPresentModeKHR present_modes[] = { VK_PRESENT_MODE_FIFO_KHR };
#endif
    wd-&gt;PresentMode = ImGui_ImplVulkanH_SelectPresentMode(g_PhysicalDevice, wd-&gt;Surface, &amp;present_modes[0], IM_ARRAYSIZE(present_modes));
</code><button class="copy-code-button">复制</button></pre></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="创建SwapChain" class="heading" id="创建SwapChain"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建SwapChain<div class="heading-after">...</div></h3><div class="heading-children"><div><p>首先初始化CreateInfo结构体。而后进行SwapChain的创建以及对应Image缓冲的创建。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkSwapchainCreateInfoKHR info = {};
info.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
info.surface = wd-&gt;Surface;
info.minImageCount = min_image_count;
info.imageFormat = wd-&gt;SurfaceFormat.format;
info.imageColorSpace = wd-&gt;SurfaceFormat.colorSpace;
info.imageArrayLayers = 1;
info.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
info.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;           // Assume that graphics family == present family
info.preTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
info.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
info.presentMode = wd-&gt;PresentMode;
info.clipped = VK_TRUE;
info.oldSwapchain = old_swapchain;
VkSurfaceCapabilitiesKHR cap; // 这个capability包含了swapchain的最小缓存数和最大缓冲数之类
err = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physical_device, wd-&gt;Surface, &amp;cap);

err = vkCreateSwapchainKHR(device, &amp;info, allocator, &amp;wd-&gt;Swapchain);
err = vkGetSwapchainImagesKHR(device, wd-&gt;Swapchain, &amp;wd-&gt;ImageCount, nullptr);
</code><button class="copy-code-button">复制</button></pre></div><div><p>在imgui里封装了FrameBuffer及其对应的Image和ImageView及需要属性，称作Frame，用来控制buffer和同步的。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">struct ImGui_ImplVulkanH_Frame
{
    VkCommandPool       CommandPool;
    VkCommandBuffer     CommandBuffer;
    VkFence             Fence;
    VkImage             Backbuffer;
    VkImageView         BackbufferView;
    VkFramebuffer       Framebuffer;
};

struct ImGui_ImplVulkanH_FrameSemaphores
{
    VkSemaphore         ImageAcquiredSemaphore;
    VkSemaphore         RenderCompleteSemaphore;
};
</code><button class="copy-code-button">复制</button></pre></div><div class="heading-wrapper"><h4 data-heading="创建Render Pass" class="heading" id="创建Render_Pass"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建Render Pass<div class="heading-after">...</div></h4><div class="heading-children"><div><p>vulkan中的Render Pass和Unity中Shader的Render Pass感觉上来说不同，拿延迟渲染举例，延迟渲染有渲染GBuffer的阶段和屏幕空间计算光照的部分(我也不知道为什么这么分成两个阶段)，整个延迟渲染是一个Render Pass，但分为了GBuffer和屏幕空间两个pipeline，所以Render Pass应该是最高层的渲染流程。[<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/418277173" rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/418277173" target="_blank">引用</a>]</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// attachment
VkAttachmentDescription attachment = {};
attachment.format = wd-&gt;SurfaceFormat.format;
attachment.samples = VK_SAMPLE_COUNT_1_BIT;
attachment.loadOp = wd-&gt;ClearEnable ? VK_ATTACHMENT_LOAD_OP_CLEAR : VK_ATTACHMENT_LOAD_OP_DONT_CARE;
attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
attachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
attachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
attachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
attachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
// attachment reference
VkAttachmentReference color_attachment = {};
color_attachment.attachment = 0;
color_attachment.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
// 一个Render Pass由若干Subpass组成
VkSubpassDescription subpass = {};
// bind point有compute和graphics两种，compute是计算管线，graphics是图形渲染管线
subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
subpass.colorAttachmentCount = 1;
subpass.pColorAttachments = &amp;color_attachment;
// subpass依赖
VkSubpassDependency dependency = {};
// VK_SUBPASS_EXTERNAL表示了该subpass之前的subpass
dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
// 0表示当前subpass吧大概
dependency.dstSubpass = 0;
dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
dependency.srcAccessMask = 0;
dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
// Render Pass Create Info
VkRenderPassCreateInfo info = {};
info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
info.attachmentCount = 1;
info.pAttachments = &amp;attachment;
info.subpassCount = 1;
info.pSubpasses = &amp;subpass;
info.dependencyCount = 1;
info.pDependencies = &amp;dependency;
err = vkCreateRenderPass(device, &amp;info, allocator, &amp;wd-&gt;RenderPass);
check_vk_result(err);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="创建ImageView" class="heading" id="创建ImageView"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建ImageView<div class="heading-after">...</div></h4><div class="heading-children"><div><blockquote><p>管线着色器不能直接访问图形对象。作为替代，image view相当于一个代理，代表了image所占据的连续内存区域，并且包含一些额外的成员用来对image进行读写。</p><p>An image view is quite literally a view into an image. It describes how to access the image and which part of the image to access, for example if it should be treated as a 2D texture depth texture without any mipmapping levels.</p></blockquote></div><div><p>也就是说，ImageView帮你实现了访问Image像素之类的方法。</p></div><div><p>下文为每个Image都给创建一个ImageView。</p></div><div><blockquote><p>因为swap chain里可以有多个image ，所以我们先发制人:为每一个image 创建一个imageView和framebuffer ，然后在绘画阶段选择一个正确的来使用。</p></blockquote></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkImageViewCreateInfo info = {};
info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
info.viewType = VK_IMAGE_VIEW_TYPE_2D;
info.format = wd-&gt;SurfaceFormat.format;
info.components.r = VK_COMPONENT_SWIZZLE_R;
info.components.g = VK_COMPONENT_SWIZZLE_G;
info.components.b = VK_COMPONENT_SWIZZLE_B;
info.components.a = VK_COMPONENT_SWIZZLE_A;
VkImageSubresourceRange image_range = { VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1 };
info.subresourceRange = image_range;
for (uint32_t i = 0; i &lt; wd-&gt;ImageCount; i++)
{
    ImGui_ImplVulkanH_Frame* fd = &amp;wd-&gt;Frames[i];
    info.image = fd-&gt;Backbuffer;
    err = vkCreateImageView(device, &amp;info, allocator, &amp;fd-&gt;BackbufferView);
    check_vk_result(err);
}
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="创建FrameBuffer" class="heading" id="创建FrameBuffer"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建FrameBuffer<div class="heading-after">...</div></h4><div class="heading-children"><div><blockquote><p>Frame buffer（帧缓冲区）封装了 color buffer image和depth buffer image。其中color buffer image为从swap chain获取的image，frame buffer的创建个数需要跟swap chain的image的数量对应，比如，双缓冲的swap chain需要对应建立2个frame buffer。</p><p>Frame buffer主要负责将render pass跟attachment(ImageView)关联起来。[<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/48066609" rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/48066609" target="_blank">引用</a>]<img style="zoom:67%" alt="v2-e3953472599247115e1d7635f8561786_720w" src="app://4f89245e4b0fbc8f4c3f1bbebd389eecada3/C:/Users/MECHREV/Downloads/v2-e3953472599247115e1d7635f8561786_720w.webp" referrerpolicy="no-referrer"></p></blockquote></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkImageView attachment[1];
VkFramebufferCreateInfo info = {};
info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
info.renderPass = wd-&gt;RenderPass;
info.attachmentCount = 1;
info.pAttachments = attachment;
info.width = wd-&gt;Width;
info.height = wd-&gt;Height;
info.layers = 1;
// 每个ImageView需要一个FrameBuffer
for (uint32_t i = 0; i &lt; wd-&gt;ImageCount; i++)
{
    ImGui_ImplVulkanH_Frame* fd = &amp;wd-&gt;Frames[i];
    attachment[0] = fd-&gt;BackbufferView;
    err = vkCreateFramebuffer(device, &amp;info, allocator, &amp;fd-&gt;Framebuffer);
    check_vk_result(err);
}
</code><button class="copy-code-button">复制</button></pre></div></div></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="创建Command Pool和CommandBuffers及其他" class="heading" id="创建Command_Pool和CommandBuffers及其他"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建Command Pool和CommandBuffers及其他<div class="heading-after">...</div></h2><div class="heading-children"><div><p>Command Buffer是储存GPU绘制命令的Buffer。同时还创建每个Command Buffer的信号量，用来完成每个渲染批次之间的同步。和所有的Pool一样，Command Buffer的内存需要用Pool来分配。</p></div><div><blockquote><p>可以看到Fence和Semaphore都会在vkQueueSubmit时作为参数传入，不同之处是，Fence用于阻塞CPU直到Queue中的命令执行结束（GPU、CPU之间的同步），而Semaphore用于不同的命令提交之间的同步（GPU、GPU之间的同步）。[<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/380719229" rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/380719229" target="_blank">引用</a>]</p></blockquote></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkResult err;
// 每个Image都要一个Command Buffer，不知道为啥
for (uint32_t i = 0; i &lt; wd-&gt;ImageCount; i++)
{
    ImGui_ImplVulkanH_Frame* fd = &amp;wd-&gt;Frames[i];
    ImGui_ImplVulkanH_FrameSemaphores* fsd = &amp;wd-&gt;FrameSemaphores[i];
    {
        // 创建Command Pool
        VkCommandPoolCreateInfo info = {};
        info.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
		// Command Buffer对象之间相互独立，不会被一起重置
        info.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
        info.queueFamilyIndex = queue_family;
        err = vkCreateCommandPool(device, &amp;info, allocator, &amp;fd-&gt;CommandPool);
        check_vk_result(err);
    }
    {
        // 创建Command Buffer
        VkCommandBufferAllocateInfo info = {};
        info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        info.commandPool = fd-&gt;CommandPool;
        // Primary Command Buffer不能被其他Command Buffer调用
        info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        info.commandBufferCount = 1;
        err = vkAllocateCommandBuffers(device, &amp;info, &amp;fd-&gt;CommandBuffer);
        check_vk_result(err);
    }
    {
        // 创建fence
        VkFenceCreateInfo info = {};
        info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
        info.flags = VK_FENCE_CREATE_SIGNALED_BIT;
        err = vkCreateFence(device, &amp;info, allocator, &amp;fd-&gt;Fence);
        check_vk_result(err);
    }
    {
        // 创建获取和完成的信号量
        // 其中Aquired是为了等待上一帧渲染完之后，立即获取到下一个Image
        VkSemaphoreCreateInfo info = {};
        info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
        err = vkCreateSemaphore(device, &amp;info, allocator, &amp;fsd-&gt;ImageAcquiredSemaphore);
        check_vk_result(err);
        err = vkCreateSemaphore(device, &amp;info, allocator, &amp;fsd-&gt;RenderCompleteSemaphore);
        check_vk_result(err);
    }
}
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h2 data-heading="创建管线" class="heading" id="创建管线"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建管线<div class="heading-after">...</div></h2><div class="heading-children"><div><p>一个Sampler包含了LOD(mip)，Filter(插值)，adressMode(平铺方式(即uv范围之外如何进行采样))</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkSamplerCreateInfo info = {};
info.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
info.magFilter = VK_FILTER_LINEAR;
info.minFilter = VK_FILTER_LINEAR;
info.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
info.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
info.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
info.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
info.minLod = -1000;
info.maxLod = 1000;
info.maxAnisotropy = 1.0f;
err = vkCreateSampler(v-&gt;Device, &amp;info, v-&gt;Allocator, &amp;bd-&gt;FontSampler);
</code><button class="copy-code-button">复制</button></pre></div><div class="heading-wrapper"><h3 data-heading="Set DescriptorSetLayout" class="heading" id="Set_DescriptorSetLayout"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Set DescriptorSetLayout<div class="heading-after">...</div></h3><div class="heading-children"><div><p>前文说到，一个descriptor大概算是Shader里的一个变量，大概需要将descriptor绑定到真实的GPU变量上。在以此创建LayoutBingding之后再创建Layout。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkSampler sampler[1] = {bd-&gt;FontSampler};
VkDescriptorSetLayoutBinding binding[1] = {};
binding[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
binding[0].descriptorCount = 1;
binding[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
binding[0].pImmutableSamplers = sampler; 
VkDescriptorSetLayoutCreateInfo info = {};
info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
info.bindingCount = 1;
info.pBindings = binding;
err = vkCreateDescriptorSetLayout(v-&gt;Device, &amp;info, v-&gt;Allocator, &amp;bd-&gt;DescriptorSetLayout);
check_vk_result(err);
</code><button class="copy-code-button">复制</button></pre></div><div><p><del>如果要创建例如MVP之类的变量(错误的，变换矩阵push constant就好)</del>，LayoutBinding可以使用下列代码：</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkDescriptorSetLayoutBinding layout_binding = {};
// bingding表示是DescriptorSet中的第几个
layout_binding.binding = 0;
layout_binding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
// count表示该DescriptorSet里有多少个Descriptor
layout_binding.descriptorCount = 1;
layout_binding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
layout_binding.pImmutableSamplers = NULL;

VkDescriptorSetLayoutCreateInfo descriptor_layout = {};
descriptor_layout.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
descriptor_layout.pNext = NULL;
descriptor_layout.bindingCount = 1;
descriptor_layout.pBindings = layout_bindings;

info.desc_layout.resize(NUM_DESCRIPTOR_SETS);
res = vkCreateDescriptorSetLayout(info.device, &amp;descriptor_layout, NULL, info.desc_layout.data());
assert(res == VK_SUCCESS);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h3 data-heading="Set PipelineLayout" class="heading" id="Set_PipelineLayout"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Set PipelineLayout<div class="heading-after">...</div></h3><div class="heading-children"><div><p>实际上在创建SetLayout之后应该创建Set实例的，但是imgui是先把这些layout信息创建好之后调用ImGui_ImplVulkan_CreatePipeline一起创建pipeline。</p></div><div><p>下列代码是将两个vec2类型的uniform绑定到了PipelineLayout里。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Constants: we are using 'vec2 offset' and 'vec2 scale' instead of a full 3d projection matrix
// 和OpenGL一样的，需要手动指定变量的偏移和大小
VkPushConstantRange push_constants[1] = {};
push_constants[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
// 由于是第一个变量 因此offset == 0
push_constants[0].offset = sizeof(float) * 0;
push_constants[0].size = sizeof(float) * 4;
VkDescriptorSetLayout set_layout[1] = { bd-&gt;DescriptorSetLayout };
VkPipelineLayoutCreateInfo layout_info = {};
layout_info.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
layout_info.setLayoutCount = 1;
// 绑定数个DescriptorSetLayout
layout_info.pSetLayouts = set_layout;
layout_info.pushConstantRangeCount = 1;
layout_info.pPushConstantRanges = push_constants;
err = vkCreatePipelineLayout(v-&gt;Device, &amp;layout_info, v-&gt;Allocator, &amp;bd-&gt;PipelineLayout);
check_vk_result(err);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h3 data-heading="创建Shader" class="heading" id="创建Shader"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建Shader<div class="heading-after">...</div></h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="Shader Module" class="heading" id="Shader_Module"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Shader Module<div class="heading-after">...</div></h4><div class="heading-children"><div><p>创建Vertex Shader和Fragment Shader。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkShaderModuleCreateInfo vert_info = {};
vert_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
vert_info.codeSize = sizeof(__glsl_shader_vert_spv);
vert_info.pCode = (uint32_t*)__glsl_shader_vert_spv;
VkResult err = vkCreateShaderModule(device, &amp;vert_info, allocator, &amp;bd-&gt;ShaderModuleVert);
check_vk_result(err);

VkShaderModuleCreateInfo frag_info = {};
frag_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
frag_info.codeSize = sizeof(__glsl_shader_frag_spv);
frag_info.pCode = (uint32_t*)__glsl_shader_frag_spv;
VkResult err = vkCreateShaderModule(device, &amp;frag_info, allocator, &amp;bd-&gt;ShaderModuleFrag);
check_vk_result(err);
</code><button class="copy-code-button">复制</button></pre></div><div><p>上面的codeSize居然是编译过后的spv中间代码的长度——也就是说__glsl_shader_frag_spv是纯纯spv中间码，何其的hardcode！</p></div><div><p>下面是编译之前的Vertex和Fragment Sahder。</p></div><div><pre class="language-glsl" tabindex="0"><code class="language-glsl is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">450</span> core</span></span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec2</span> aPos<span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec2</span> aUV<span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec4</span> aColor<span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>push_constant<span class="token punctuation">)</span> <span class="token keyword">uniform</span> uPushConstant <span class="token punctuation">{</span> <span class="token keyword">vec2</span> uScale<span class="token punctuation">;</span> <span class="token keyword">vec2</span> uTranslate<span class="token punctuation">;</span> <span class="token punctuation">}</span> pc<span class="token punctuation">;</span>

<span class="token keyword">out</span> gl_PerVertex <span class="token punctuation">{</span> <span class="token keyword">vec4</span> gl_Position<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">out</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span> <span class="token keyword">vec4</span> Color<span class="token punctuation">;</span> <span class="token keyword">vec2</span> UV<span class="token punctuation">;</span> <span class="token punctuation">}</span> Out<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Out<span class="token punctuation">.</span>Color <span class="token operator">=</span> aColor<span class="token punctuation">;</span>
    Out<span class="token punctuation">.</span>UV <span class="token operator">=</span> aUV<span class="token punctuation">;</span>
    gl_Position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPos <span class="token operator">*</span> pc<span class="token punctuation">.</span>uScale <span class="token operator">+</span> pc<span class="token punctuation">.</span>uTranslate<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">复制</button></pre></div><div><pre class="language-glsl" tabindex="0"><code class="language-glsl is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">450</span> core</span></span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">out</span> <span class="token keyword">vec4</span> fColor<span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>set<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> binding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> sTexture<span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span> <span class="token keyword">vec4</span> Color<span class="token punctuation">;</span> <span class="token keyword">vec2</span> UV<span class="token punctuation">;</span> <span class="token punctuation">}</span> In<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    fColor <span class="token operator">=</span> In<span class="token punctuation">.</span>Color <span class="token operator">*</span> <span class="token function">texture</span><span class="token punctuation">(</span>sTexture<span class="token punctuation">,</span> In<span class="token punctuation">.</span>UV<span class="token punctuation">.</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="Shader Stage" class="heading" id="Shader_Stage"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Shader Stage<div class="heading-after">...</div></h4><div class="heading-children"><div><p>每个Stage对应一个可编程(大概)的着色器。看了下Stage类型蛮多的，真正能用与渲染的大概只有tessellation和geometry，compute大概可以辅助计算？</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkPipelineShaderStageCreateInfo stage[2] = {};
stage[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
stage[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
stage[0].module = bd-&gt;ShaderModuleVert;
stage[0].pName = "main";

stage[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
stage[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
stage[1].module = bd-&gt;ShaderModuleFrag;
stage[1].pName = "main";
</code><button class="copy-code-button">复制</button></pre></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="创建Vertex Input Description" class="heading" id="创建Vertex_Input_Description"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建Vertex Input Description<div class="heading-after">...</div></h3><div class="heading-children"><div><p>必须注意，description不是descriptor！！！！description只是用来描述Vertex Input的结构。<strong>Vertex Buffer在运行时进行绑定，下面的binding就是指绑定的buffer</strong>。</p></div><div><blockquote><p>Binding Point对Vertex Buffer的数据组织是无知的，它只关心数据块的大小和以什么样的速度（每Vertex/每Instance）更换对应的数据块，这些东西由Binding Description来解释。[<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/450157594" rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/450157594" target="_blank">引用</a>]</p><p>Vertex Shader 对Vertex Buffer Binding是无知的，它所关心的只有Location。而Attribute Description就负责将一个Stride大小的数据块解释为Vertex Shader所关心的Location。</p></blockquote></div><div><p>在后面记录command，进行管线与Buffer的绑定时需要按照此时的Description来。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Vertex Input Binding Description
// 用来描述Vertex Input的大小和输入速度
VkVertexInputBindingDescription binding_desc[1] = {};
// 下面ImDrawVert其实就是包含了pos、uv、color三个属性的结构体。
binding_desc[0].stride = sizeof(ImDrawVert);
binding_desc[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

// Vertex Input Attribute Description
// 用来描述所有Vertex Input的格式(我觉得这里用layout来描述比较合适)
// 第一个属性是vector2的position，location为0，offset为0
VkVertexInputAttributeDescription attribute_desc[3] = {};
attribute_desc[0].location = 0;
attribute_desc[0].binding = binding_desc[0].binding;
attribute_desc[0].format = VK_FORMAT_R32G32_SFLOAT;
attribute_desc[0].offset = IM_OFFSETOF(ImDrawVert, pos);
// 第二个属性是vector2的uv，location为1，offset为8
attribute_desc[1].location = 1;
attribute_desc[1].binding = binding_desc[0].binding;
attribute_desc[1].format = VK_FORMAT_R32G32_SFLOAT;
attribute_desc[1].offset = IM_OFFSETOF(ImDrawVert, uv);
// 第三个属性为color的col，location为2，offset为16
attribute_desc[2].location = 2;
attribute_desc[2].binding = binding_desc[0].binding;
attribute_desc[2].format = VK_FORMAT_R8G8B8A8_UNORM;
attribute_desc[2].offset = IM_OFFSETOF(ImDrawVert, col);
</code><button class="copy-code-button">复制</button></pre></div><div><p><img alt="v2-97dd2ffbd0fff80f1f8dfc734f6ea073_r" src="app://4f89245e4b0fbc8f4c3f1bbebd389eecada3/C:/%5CUsers%5CMECHREV%5CDownloads%5Cv2-97dd2ffbd0fff80f1f8dfc734f6ea073_r.jpg" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="创建管线信息" class="heading" id="创建管线信息"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建管线信息<div class="heading-after">...</div></h3><div class="heading-children"><div><p>创建一大堆CreateInfo为创建pipeline做准备。</p></div><div class="heading-wrapper"><h4 data-heading="Shader Stage" class="heading" id="Shader_Stage"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Shader Stage<div class="heading-after">...</div></h4><div class="heading-children"><div><p>在这里绑定之前创建好的shader stage。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkPipelineShaderStageCreateInfo stage[2] = {};
stage[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
stage[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
stage[0].module = bd-&gt;ShaderModuleVert;
stage[0].pName = "main";
stage[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
stage[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
stage[1].module = bd-&gt;ShaderModuleFrag;
stage[1].pName = "main";
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="Vertex Input" class="heading" id="Vertex_Input"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Vertex Input<div class="heading-after">...</div></h4><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkPipelineVertexInputStateCreateInfo vertex_info = {};
vertex_info.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
vertex_info.vertexBindingDescriptionCount = 1;
vertex_info.pVertexBindingDescriptions = binding_desc;
vertex_info.vertexAttributeDescriptionCount = 3;
// 用到了上文的Vertex Input Description
vertex_info.pVertexAttributeDescriptions = attribute_desc;
</code><button class="copy-code-button">复制</button></pre></div><div><p>需要在录制Pipeline Command的阶段进行绑定。</p></div></div></div><div class="heading-wrapper"><h4 data-heading="Assembly" class="heading" id="Assembly"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Assembly<div class="heading-after">...</div></h4><div class="heading-children"><div><p>可以说就是index的信息。TRIANGLE_LIST就是每个三角形都有三个单独的顶点，蛮浪费空间的。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkPipelineInputAssemblyStateCreateInfo ia_info = {};
ia_info.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
ia_info.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
</code><button class="copy-code-button">复制</button></pre></div><div><p>需要在录制Pipeline Command的阶段进行绑定。</p></div></div></div><div class="heading-wrapper"><h4 data-heading="Viewport" class="heading" id="Viewport"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Viewport<div class="heading-after">...</div></h4><div class="heading-children"><div><p>视窗描述了输出将被渲染到的帧缓冲区域。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkPipelineViewportStateCreateInfo viewport_info = {};
viewport_info.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
viewport_info.viewportCount = 1;
// scissor是对视口进行裁剪
viewport_info.scissorCount = 1;
</code><button class="copy-code-button">复制</button></pre></div><div><p>需要在录制Pipeline Command的阶段进行绑定。scissor也需要进行设置。</p></div></div></div><div class="heading-wrapper"><h4 data-heading="rasterization" class="heading" id="rasterization"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>rasterization<div class="heading-after">...</div></h4><div class="heading-children"><div><p>光栅化是将三角形填充成片元的过程。</p></div><div><p>这里的polygon mode是指从三角面生成片元的方式。让人没想到的是，原来vk的光栅化的polygon mode不只是只有三角形填充，还有以下模式：</p></div><div><ul><li data-line="0"><p>VK_POLYGON_MODE_FILL。填充</p></li><li data-line="2"><p>VK_POLYGON_MODE_LINE。只光栅化三角形的边，即wireframe。此模式可以设置linewidth，而最大linewidth取决于硬件，由此可见这是一个硬件处理的渲染方式(废话)。</p></li><li data-line="4"><p>VK_POLYGON_MODE_POINT。渲染顶点。</p></li><li data-line="6"><p><code>VK_POLYGON_MODE_FILL_RECTANGLE_NV</code> specifies that polygons are rendered using polygon rasterization rules, modified to consider a sample within the primitive if the sample location is inside the axis-aligned bounding box of the triangle after projection. Note that the <strong>barycentric weights used in attribute interpolation</strong> <strong>can</strong> extend outside the range [0,1] when these primitives are shaded. Special treatment is given to a sample position on the boundary edge of the bounding box. In such a case, if two rectangles lie on either side of a common edge (with identical endpoints) on which a sample position lies, then exactly one of the triangles <strong>must</strong> produce a fragment that covers that sample during rasterization.</p><p>Polygons rendered in <code>VK_POLYGON_MODE_FILL_RECTANGLE_NV</code> mode <strong>may</strong> be clipped by the frustum or by user clip planes. If clipping is applied, the triangle is culled rather than clipped.</p><p>Area calculation and facingness are determined for <code>VK_POLYGON_MODE_FILL_RECTANGLE_NV</code> mode using the triangle’s vertices.<br>好像是说此模式只会将AABB包围盒里的采样点光栅化为片元(难道说普通的fill会把包围盒外边的也渲染？)<br>看了以上文字才发现自己图形学知识浅薄，之前一直知道四边形使用双线性双三次插值，以为三角形也可以类推，没想到三角形插值使用的是三角形的<strong>重心坐标系</strong>进行插值，不过原理也极其简单，把顶点A当作起点，AB，AC作为基向量就可以表示三角形内外所有位置的坐标，进而进行插值了。[<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/149836719" rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/149836719" target="_blank">文章</a>]</p></li></ul></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkPipelineRasterizationStateCreateInfo raster_info = {};
raster_info.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
raster_info.polygonMode = VK_POLYGON_MODE_FILL;
// 可以进行正面或背面剔除(由此可见 剔除是在rasterization进行的，shaderlab只是进行了一些配置)
raster_info.cullMode = VK_CULL_MODE_NONE;
// frontFace表示 识别为正面的三角形的点的顺序 这里表示当组成三角面的三个点顺序是顺时针时为正面
raster_info.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
raster_info.lineWidth = 1.0f;
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="Multisample" class="heading" id="Multisample"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Multisample<div class="heading-after">...</div></h4><div class="heading-children"><div><p>MSAA</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkPipelineMultisampleStateCreateInfo ms_info = {};
ms_info.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
ms_info.rasterizationSamples = (MSAASamples != 0) ? MSAASamples : VK_SAMPLE_COUNT_1_BIT;
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="ColorBlendAttachment" class="heading" id="ColorBlendAttachment"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>ColorBlendAttachment<div class="heading-after">...</div></h4><div class="heading-children"><div><p>在fragment shader渲染完之后的像素如何和帧缓冲内的像素进行混合。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkPipelineColorBlendAttachmentState color_attachment[1] = {};
color_attachment[0].blendEnable = VK_TRUE;
color_attachment[0].srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
color_attachment[0].dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
color_attachment[0].colorBlendOp = VK_BLEND_OP_ADD;
color_attachment[0].srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
color_attachment[0].dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
color_attachment[0].alphaBlendOp = VK_BLEND_OP_ADD;
// writemask指明要输出哪些通道
color_attachment[0].colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="Stencil" class="heading" id="Stencil"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Stencil<div class="heading-after">...</div></h4><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkPipelineDepthStencilStateCreateInfo depth_info = {};
depth_info.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="ColorBlend" class="heading" id="ColorBlend"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>ColorBlend<div class="heading-after">...</div></h4><div class="heading-children"><div><p>把上面的ColorBlendAttachment加进去。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkPipelineColorBlendStateCreateInfo blend_info = {};
blend_info.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
blend_info.attachmentCount = 1;
blend_info.pAttachments = color_attachment;
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="Dynamic" class="heading" id="Dynamic"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Dynamic<div class="heading-after">...</div></h4><div class="heading-children"><div><p>有些属性是可以不修改管线，仅仅改变参数就可以修改的。下列代码就将ViewPort的大小，Scissor作为可动态修改的。</p></div><div><p>以下枚举内的都是可动态修改的。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">typedef enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
    VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
    VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
    VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
    VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
    VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = 1000259000,
    VK_DYNAMIC_STATE_CULL_MODE_EXT = 1000267000,
    VK_DYNAMIC_STATE_FRONT_FACE_EXT = 1000267001,
    VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = 1000267002,
    VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT = 1000267003,
    VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT = 1000267004,
    VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT = 1000267005,
    VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT = 1000267006,
    VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT = 1000267007,
    VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT = 1000267008,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT = 1000267009,
    VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT = 1000267010,
    VK_DYNAMIC_STATE_STENCIL_OP_EXT = 1000267011,
    VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
    VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
    VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT = 1000377001,
    VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT = 1000377002,
    VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
    VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT = 1000377004,
    VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
    VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
} VkDynamicState;
</code><button class="copy-code-button">复制</button></pre></div><div><p>下为imgui中使用的代码。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkDynamicState dynamic_states[2] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR };
VkPipelineDynamicStateCreateInfo dynamic_state = {};
dynamic_state.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
dynamic_state.dynamicStateCount = (uint32_t)IM_ARRAYSIZE(dynamic_states);
dynamic_state.pDynamicStates = dynamic_states;
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="创建管线" class="heading" id="创建管线"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建管线<div class="heading-after">...</div></h4><div class="heading-children"><div><p>填充各种info然后创建pipeline。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkGraphicsPipelineCreateInfo info = {};
info.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
info.flags = bd-&gt;PipelineCreateFlags;
info.stageCount = 2;
info.pStages = stage;
info.pVertexInputState = &amp;vertex_info;
info.pInputAssemblyState = &amp;ia_info;
info.pViewportState = &amp;viewport_info;
info.pRasterizationState = &amp;raster_info;
info.pMultisampleState = &amp;ms_info;
info.pDepthStencilState = &amp;depth_info;
info.pColorBlendState = &amp;blend_info;
info.pDynamicState = &amp;dynamic_state;
info.layout = bd-&gt;PipelineLayout;
info.renderPass = renderPass;
info.subpass = subpass;
VkResult err = vkCreateGraphicsPipelines(device, pipelineCache, 1, &amp;info, allocator, pipeline);
</code><button class="copy-code-button">复制</button></pre></div></div></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="渲染字体" class="heading" id="渲染字体"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>渲染字体<div class="heading-after">...</div></h2><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Use any command queue
// 这里的FrameIndex是窗口渲染管线的RenderPass的第二个FrameBuffer
VkCommandPool command_pool = wd-&gt;Frames[wd-&gt;FrameIndex].CommandPool;
VkCommandBuffer command_buffer = wd-&gt;Frames[wd-&gt;FrameIndex].CommandBuffer;

err = vkResetCommandPool(g_Device, command_pool, 0);
check_vk_result(err);
VkCommandBufferBeginInfo begin_info = {};
begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
begin_info.flags |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
// 从这里开始设置渲染命令
err = vkBeginCommandBuffer(command_buffer, &amp;begin_info);
check_vk_result(err);
// 创建字体纹理，详细细节参见“文字渲染.md”
ImGui_ImplVulkan_CreateFontsTexture(command_buffer);

VkSubmitInfo end_info = {};
end_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
end_info.commandBufferCount = 1;
end_info.pCommandBuffers = &amp;command_buffer;
err = vkEndCommandBuffer(command_buffer);
check_vk_result(err);
// 提交到队列
err = vkQueueSubmit(g_Queue, 1, &amp;end_info, VK_NULL_HANDLE);
check_vk_result(err);
// 等待所有提交的命令执行完
err = vkDeviceWaitIdle(g_Device);
check_vk_result(err);
ImGui_ImplVulkan_DestroyFontUploadObjects();
</code><button class="copy-code-button">复制</button></pre></div><div class="heading-wrapper"><h3 data-heading="字体纹理" class="heading" id="字体纹理"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>字体纹理<div class="heading-after">...</div></h3><div class="heading-children"><div><p>以上是整体的结构，其中imgui的函数ImGui_ImplVulkan_CreateFontsTexture还蛮复杂，文字渲染.md文件里说明了这一过程。此过程主要是读取创建了文字的atlas并赋予给buffer、创建其Image、ImageView、DescriptorSet，而提交给Command Buffer的命令主要是将Buffer里的数据复制给Image。由于设置了MemoryBarrier，因此这个过程放在上列代码中不会有任何依赖&amp;乱序&amp;缓存不一致的问题。</p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="进入MainLoop" class="heading" id="进入MainLoop"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>进入MainLoop<div class="heading-after">...</div></h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="glfwPollEvents()" class="heading" id="glfwPollEvents()"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>glfwPollEvents()<div class="heading-after">...</div></h3><div class="heading-children"><div><p>获取events</p></div></div></div><div class="heading-wrapper"><h3 data-heading="设置Swap Chain大小" class="heading" id="设置Swap_Chain大小"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>设置Swap Chain大小<div class="heading-after">...</div></h3><div class="heading-children"><div><p>别忘了GLFW是一组和窗口相关的api。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">if (g_SwapChainRebuild)
{
    int width, height;
    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    if (width &gt; 0 &amp;&amp; height &gt; 0)
    {
        ImGui_ImplVulkan_SetMinImageCount(g_MinImageCount);
        ImGui_ImplVulkanH_CreateOrResizeWindow(g_Instance, g_PhysicalDevice, g_Device, &amp;g_MainWindowData, g_QueueFamily, g_Allocator, width, height, g_MinImageCount);
        g_MainWindowData.FrameIndex = 0;
        g_SwapChainRebuild = false;
    }
}
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h3 data-heading="开始Dear ImGUI帧" class="heading" id="开始Dear_ImGUI帧"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>开始Dear ImGUI帧<div class="heading-after">...</div></h3><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// 将前一帧的backend给unuse
ImGui_ImplVulkan_NewFrame();
ImGui_ImplGlfw_NewFrame();
ImGui::NewFrame();
</code><button class="copy-code-button">复制</button></pre></div><div><p>之后就是自己写一些窗口布局的代码。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="渲染帧" class="heading" id="渲染帧"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>渲染帧<div class="heading-after">...</div></h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="获取Swap Chain中下一个Image" class="heading" id="获取Swap_Chain中下一个Image"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>获取Swap Chain中下一个Image<div class="heading-after">...</div></h4><div class="heading-children"><div><blockquote><p>在一帧渲染开始前会调用 <a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//www.khronos.org/registry/vulkan/specs/1.2-khr-extensions/html/vkspec.html%23vkAcquireNextImageKHR" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//www.khronos.org/registry/vulkan/specs/1.2-khr-extensions/html/vkspec.html%23vkAcquireNextImageKHR" target="_blank">vkAcquireNextImageKHR</a> 获得 swapchain 中的 image 索引，</p><blockquote><p>When successful,<code>vkAcquireNextImageKHR</code>acquires a presentable image from<code>swapchain</code>that an application <strong>can</strong> use, and sets<code>pImageIndex</code>to the index of that image within the swapchain.</p></blockquote><p>但是这并不意味着我们可以立即开始渲染，因为</p><blockquote><p>The presentation engine <strong>may</strong> not have finished reading from the image at the time it is acquired, so the application <strong>must</strong> use<code>semaphore</code>and/or<code>fence</code>to ensure that the image layout and contents are not modified until the presentation engine reads have completed.</p></blockquote><p>Image 可能还正在被读取，此时写入会破坏数据，因此必须要使用 semaphore 或 fence 保证读取完毕后再开始写入操作。</p></blockquote></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">vkAcquireNextImageKHR(g_Device, wd-&gt;Swapchain, UINT64_MAX, image_acquired_semaphore, VK_NULL_HANDLE, &amp;wd-&gt;FrameIndex);
</code><button class="copy-code-button">复制</button></pre></div><div><p>通过获取Image的参数可知，其中使用到了之前创建的semaphore，在上一帧读取完之后才会立刻执行。</p></div><div><p>然后再等待Fences，暂时不知道为什么。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">ImGui_ImplVulkanH_Frame* fd = &amp;wd-&gt;Frames[wd-&gt;FrameIndex];
{
    err = vkWaitForFences(g_Device, 1, &amp;fd-&gt;Fence, VK_TRUE, UINT64_MAX);    // wait indefinitely instead of periodically checking
    check_vk_result(err);

    err = vkResetFences(g_Device, 1, &amp;fd-&gt;Fence);
    check_vk_result(err);
}
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="重置命令缓冲池开始录制命令缓冲" class="heading" id="重置命令缓冲池开始录制命令缓冲"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>重置命令缓冲池开始录制命令缓冲<div class="heading-after">...</div></h4><div class="heading-children"><div><p>看起来每帧都需要重置Command Pool之后再操作Command Buffers。</p></div><div><blockquote><p>Resetting a command pool recycles all of the resources from all of the command buffers allocated from the command pool back to the command pool. All command buffers that have been allocated from the command pool are put in the initial state.</p></blockquote></div><div><p>也就是说，ResetCommandPool会将池中所有Command Buffer都重置，即将其状态改变为Initial State。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">err = vkResetCommandPool(g_Device, fd-&gt;CommandPool, 0);
check_vk_result(err);
VkCommandBufferBeginInfo info = {};
info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
info.flags |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
err = vkBeginCommandBuffer(fd-&gt;CommandBuffer, &amp;info);
check_vk_result(err);
</code><button class="copy-code-button">复制</button></pre></div><div><p>其中vkBeginCommandBuffer会将Command Buffer的状态从“Initial State”变为“Recording State”，之后再调用vkCmd*之类的指令，就会记录到该Command Buffer里。</p></div></div></div><div class="heading-wrapper"><h4 data-heading="记录ImGUI中的Command" class="heading" id="记录ImGUI中的Command"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>记录ImGUI中的Command<div class="heading-after">...</div></h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="开始Render Pass" class="heading" id="开始Render_Pass"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>开始Render Pass<div class="heading-after">...</div></h5><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkRenderPassBeginInfo info = {};
info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
info.renderPass = wd-&gt;RenderPass;
info.framebuffer = fd-&gt;Framebuffer;
info.renderArea.extent.width = wd-&gt;Width;
info.renderArea.extent.height = wd-&gt;Height;
info.clearValueCount = 1;
info.pClearValues = &amp;wd-&gt;ClearValue;
vkCmdBeginRenderPass(fd-&gt;CommandBuffer, &amp;info, VK_SUBPASS_CONTENTS_INLINE);
</code><button class="copy-code-button">复制</button></pre></div><div><p>vkCmdBeginRenderPass到vkCmdEndRenderPass之间的代码会记录到RenderPass中，spec上说会记录到RenderPass的第一个SubPass里(不知道其他RenderPass怎么搞暂时)。</p></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="准备Vertex和Index数据(Buffer)" class="heading" id="准备Vertex和Index数据(Buffer)"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>准备Vertex和Index数据(Buffer)<div class="heading-after">...</div></h4><div class="heading-children"><div><p>在需要用三角形进行渲染时会先创建Vertex和Index。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded"> // Create or resize the vertex/index buffers
 size_t vertex_size = draw_data-&gt;TotalVtxCount * sizeof(ImDrawVert);
 size_t index_size = draw_data-&gt;TotalIdxCount * sizeof(ImDrawIdx);
 if (rb-&gt;VertexBuffer == VK_NULL_HANDLE || rb-&gt;VertexBufferSize &lt; vertex_size)
     CreateOrResizeBuffer(rb-&gt;VertexBuffer, rb-&gt;VertexBufferMemory, rb-&gt;VertexBufferSize, vertex_size, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT);
 if (rb-&gt;IndexBuffer == VK_NULL_HANDLE || rb-&gt;IndexBufferSize &lt; index_size)
     CreateOrResizeBuffer(rb-&gt;IndexBuffer, rb-&gt;IndexBufferMemory, rb-&gt;IndexBufferSize, index_size, VK_BUFFER_USAGE_INDEX_BUFFER_BIT);
</code><button class="copy-code-button">复制</button></pre></div><div><p>上面的CreateOrResizeBuffer又是ImGUI封装的函数，其函数定义如下：</p></div><div><p>它们分别创建了Vertex和Index Buffer。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded"> static void CreateOrResizeBuffer(VkBuffer&amp; buffer, VkDeviceMemory&amp; buffer_memory, VkDeviceSize&amp; p_buffer_size, size_t new_size, VkBufferUsageFlagBits usage)
 {
     ImGui_ImplVulkan_Data* bd = ImGui_ImplVulkan_GetBackendData();
     ImGui_ImplVulkan_InitInfo* v = &amp;bd-&gt;VulkanInitInfo;
     VkResult err;
     if (buffer != VK_NULL_HANDLE)
         vkDestroyBuffer(v-&gt;Device, buffer, v-&gt;Allocator);
     if (buffer_memory != VK_NULL_HANDLE)
         vkFreeMemory(v-&gt;Device, buffer_memory, v-&gt;Allocator);
 
     // ceil，奇怪的是，明明在创建字体Atlas的贴图时并没有考虑对齐的问题
     // 试了一下，其实不对齐也没有问题
     VkDeviceSize vertex_buffer_size_aligned = ((new_size - 1) / bd-&gt;BufferMemoryAlignment + 1) * bd-&gt;BufferMemoryAlignment;
     VkBufferCreateInfo buffer_info = {};
     buffer_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
     buffer_info.size = vertex_buffer_size_aligned;
     // usage用来表明是Vertex还是Index之类
     buffer_info.usage = usage;
     buffer_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
     // 创建Buffer
     err = vkCreateBuffer(v-&gt;Device, &amp;buffer_info, v-&gt;Allocator, &amp;buffer);
     check_vk_result(err);
 
     VkMemoryRequirements req;
     vkGetBufferMemoryRequirements(v-&gt;Device, buffer, &amp;req);
     bd-&gt;BufferMemoryAlignment = (bd-&gt;BufferMemoryAlignment &gt; req.alignment) ? bd-&gt;BufferMemoryAlignment : req.alignment;
     VkMemoryAllocateInfo alloc_info = {};
     alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
     alloc_info.allocationSize = req.size;
     alloc_info.memoryTypeIndex = ImGui_ImplVulkan_MemoryType(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, req.memoryTypeBits);
     // 为Buffer分配内存
     err = vkAllocateMemory(v-&gt;Device, &amp;alloc_info, v-&gt;Allocator, &amp;buffer_memory);
     check_vk_result(err);
     // 将Buffer和内存绑定
     err = vkBindBufferMemory(v-&gt;Device, buffer, buffer_memory, 0);
     check_vk_result(err);
     p_buffer_size = req.size;
 }
</code><button class="copy-code-button">复制</button></pre></div><div><p>在创建了Vertex和Index Buffer之后，就需要对其赋值。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded"> // Upload vertex/index data into a single contiguous GPU buffer
 ImDrawVert* vtx_dst = nullptr;
 ImDrawIdx* idx_dst = nullptr;
 VkResult err = vkMapMemory(v-&gt;Device, rb-&gt;VertexBufferMemory, 0, rb-&gt;VertexBufferSize, 0, (void**)(&amp;vtx_dst));
 check_vk_result(err);
 err = vkMapMemory(v-&gt;Device, rb-&gt;IndexBufferMemory, 0, rb-&gt;IndexBufferSize, 0, (void**)(&amp;idx_dst));
 check_vk_result(err);
 // 将主机内存中的相关数据拷贝到Buffer
 for (int n = 0; n &lt; draw_data-&gt;CmdListsCount; n++)
 {
     const ImDrawList* cmd_list = draw_data-&gt;CmdLists[n];
     memcpy(vtx_dst, cmd_list-&gt;VtxBuffer.Data, cmd_list-&gt;VtxBuffer.Size * sizeof(ImDrawVert));
     memcpy(idx_dst, cmd_list-&gt;IdxBuffer.Data, cmd_list-&gt;IdxBuffer.Size * sizeof(ImDrawIdx));
     vtx_dst += cmd_list-&gt;VtxBuffer.Size;
     idx_dst += cmd_list-&gt;IdxBuffer.Size;
 }
 // 将Memory刷到GPU(大概) 有一个疑问，就是这个刷入的过程并不是cmd的，不知道会不会有同步问题
 VkMappedMemoryRange range[2] = {};
 range[0].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
 range[0].memory = rb-&gt;VertexBufferMemory;
 range[0].size = VK_WHOLE_SIZE;
 range[1].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
 range[1].memory = rb-&gt;IndexBufferMemory;
 range[1].size = VK_WHOLE_SIZE;
 err = vkFlushMappedMemoryRanges(v-&gt;Device, 2, range);
 check_vk_result(err);
 vkUnmapMemory(v-&gt;Device, rb-&gt;VertexBufferMemory);
 vkUnmapMemory(v-&gt;Device, rb-&gt;IndexBufferMemory);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="记录Pipeline指令" class="heading" id="记录Pipeline指令"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>记录Pipeline指令<div class="heading-after">...</div></h4><div class="heading-children"><div><p>调用封装过后的这个ImGUI函数。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">ImGui_ImplVulkan_RenderDrawData(draw_data, fd-&gt;CommandBuffer);
</code><button class="copy-code-button">复制</button></pre></div><div><p>巨复杂无比。</p></div><div class="heading-wrapper"><h5 data-heading="pipeline绑定" class="heading" id="pipeline绑定"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>pipeline绑定<div class="heading-after">...</div></h5><div class="heading-children"><div><p>在里面，先进行了pipeline的绑定。spec说在绑定之后，会影响和对于pipeline类型的pipeline的子序列命令，直到有新的相同pipeline类型的pipeline绑定，也就是说在此之后的cmd都是作用到当前pipeline。</p></div><div><p>VK_PIPELINE_BIND_POINT_GRAPHICS这个enum是表明了pipeline类型，称为Binding Point，显然同一时刻只能有一个对应类型的pipeline能提交指令。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">vkCmdBindPipeline(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h5 data-heading="Buffer绑定" class="heading" id="Buffer绑定"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Buffer绑定<div class="heading-after">...</div></h5><div class="heading-children"><div><p>把上一步创建的Vertex和Index Buffer绑定到当前pipeline。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">if (draw_data-&gt;TotalVtxCount &gt; 0)
{
    VkBuffer vertex_buffers[1] = { rb-&gt;VertexBuffer };
    VkDeviceSize vertex_offset[1] = { 0 };
    vkCmdBindVertexBuffers(command_buffer, 0, 1, vertex_buffers, vertex_offset);
    vkCmdBindIndexBuffer(command_buffer, rb-&gt;IndexBuffer, 0, sizeof(ImDrawIdx) == 2 ? VK_INDEX_TYPE_UINT16 : VK_INDEX_TYPE_UINT32);
}
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h5 data-heading="创建ViewPort" class="heading" id="创建ViewPort"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建ViewPort<div class="heading-after">...</div></h5><div class="heading-children"><div><p>viewport指明了片元如何从NDC坐标系转换到FrameBuffer的坐标系。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">VkViewport viewport;
viewport.x = 0;
viewport.y = 0;
viewport.width = (float)fb_width;
viewport.height = (float)fb_height;
viewport.minDepth = 0.0f;
viewport.maxDepth = 1.0f;
vkCmdSetViewport(command_buffer, 0, 1, &amp;viewport);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h5 data-heading="设置变换变量" class="heading" id="设置变换变量"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>设置变换变量<div class="heading-after">...</div></h5><div class="heading-children"><div><p>通过PushConstants将变量设置到Pipeline Layout中。注意，这种方式的变量是写到command buffer里的，比在GPU里面创建Memory要快。</p></div><div><p>可以通过这里注意到，uniform变量其实是绑定到Pipeline Layout的。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">float scale[2];
scale[0] = 2.0f / draw_data-&gt;DisplaySize.x;
scale[1] = 2.0f / draw_data-&gt;DisplaySize.y;
float translate[2];
translate[0] = -1.0f - draw_data-&gt;DisplayPos.x * scale[0];
translate[1] = -1.0f - draw_data-&gt;DisplayPos.y * scale[1];
vkCmdPushConstants(command_buffer, bd-&gt;PipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, sizeof(float) * 0, sizeof(float) * 2, scale);
vkCmdPushConstants(command_buffer, bd-&gt;PipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, sizeof(float) * 2, sizeof(float) * 2, translate);
</code><button class="copy-code-button">复制</button></pre></div><div><p>这些变量可以通过以下方式在着色器中访问：</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">layout (location = 0) in vec2 scale;
layout (location = 1) in vec2 translate;
</code><button class="copy-code-button">复制</button></pre></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="绘制DrawList" class="heading" id="绘制DrawList"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>绘制DrawList<div class="heading-after">...</div></h4><div class="heading-children"><div><p>之前的，不管是窗口还是文字还是组件，他们都将顶点之类的信息添加到了DrawList里面，在此处一并绘制。</p></div><div><p><strong>注：下文的Command List、Command Buffer、Command都是ImGUI的概念，而不是Vulkan中的概念</strong></p></div><div><p>Command结构如下:注释里面说一个Command一般是一个DrawCall。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Typically, 1 command = 1 GPU draw call (unless command is a callback)
// - VtxOffset: When 'io.BackendFlags &amp; ImGuiBackendFlags_RendererHasVtxOffset' is enabled,
//   this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.
//   Backends made for &lt;1.71. will typically ignore the VtxOffset fields.
// - The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).
struct ImDrawCmd
{
    ImVec4          ClipRect;           // 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData-&gt;DisplayPos to get clipping rectangle in "viewport" coordinates
    ImTextureID     TextureId;          // 4-8  // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
    unsigned int    VtxOffset;          // 4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be &gt;0 to support meshes larger than 64K vertices with 16-bit indices.
    unsigned int    IdxOffset;          // 4    // Start offset in index buffer.
    unsigned int    ElemCount;          // 4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
    ImDrawCallback  UserCallback;       // 4-8  // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
    void*           UserCallbackData;   // 4-8  // The draw callback code can access this.

    ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed

    // Since 1.83: returns ImTextureID associated with this draw call. Warning: DO NOT assume this is always same as 'TextureId' (we will change this function for an upcoming feature)
    inline ImTextureID GetTexID() const { return TextureId; }
};
</code><button class="copy-code-button">复制</button></pre></div><div><p>绘制伪代码如下</p></div><div><p>对于每个CommandList:</p></div><div><p>​	对于每个CommandList内的每个Command:</p></div><div><p>​ 如果Command有自定义回调函数，则调用回调函数并继续。<br>​ 否则先将Scissor范围映射到FrameBuffer坐标系，并把渲染范围限定在Viewport内，然后设置Scissor(使用vkCmdSetScissor)，试了一下如果没有Scissor限制范围，就可能会造成闪烁的情况。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Project scissor/clipping rectangles into framebuffer space
ImVec2 clip_min((pcmd-&gt;ClipRect.x - clip_off.x) * clip_scale.x, (pcmd-&gt;ClipRect.y - clip_off.y) * clip_scale.y);
ImVec2 clip_max((pcmd-&gt;ClipRect.z - clip_off.x) * clip_scale.x, (pcmd-&gt;ClipRect.w - clip_off.y) * clip_scale.y);

// Clamp to viewport as vkCmdSetScissor() won't accept values that are off bounds
if (clip_min.x &lt; 0.0f) { clip_min.x = 0.0f; }
if (clip_min.y &lt; 0.0f) { clip_min.y = 0.0f; }
if (clip_max.x &gt; fb_width) { clip_max.x = (float)fb_width; }
if (clip_max.y &gt; fb_height) { clip_max.y = (float)fb_height; }
if (clip_max.x &lt;= clip_min.x || clip_max.y &lt;= clip_min.y)
    continue;
</code><button class="copy-code-button">复制</button></pre></div><div><p>​ 然后将纹理绑定到DescriptorSet。读者可能注意到，前文已经创建、更新过不少descriptorset并进行过一些操作了，在此之前descriptorset都储存在host内存上，在这里再进行绑定，创建更新和绑定分离，能够进行复用，其实蛮好的。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Bind DescriptorSet with font or user texture
VkDescriptorSet desc_set[1] = { (VkDescriptorSet)pcmd-&gt;TextureId };
if (sizeof(ImTextureID) &lt; sizeof(ImU64))
{
    // We don't support texture switches if ImTextureID hasn't been redefined to be 64-bit. Do a flaky check that other textures haven't been used.
    IM_ASSERT(pcmd-&gt;TextureId == (ImTextureID)bd-&gt;FontDescriptorSet);
    desc_set[0] = bd-&gt;FontDescriptorSet;
}
vkCmdBindDescriptorSets(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, bd-&gt;PipelineLayout, 0, 1, desc_set, 0, nullptr);
</code><button class="copy-code-button">复制</button></pre></div><div><p>​ 最后进行绘制。vkCmdDrawIndexed这个函数的第二个参数表示需要绘制的顶点总数，第三个是绘制的实例数，第四个是绘制所用的第一个index位于Index Buffer中的base offset，第五个是用到的第一个vertex处于Vertex Buffer中的offset，最后一个是用到的第一个instance的index。这就说明Index Buffer和Vertex Buffer都已经提交完毕了(虽然我暂时还没看到)。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">vkCmdDrawIndexed(command_buffer, pcmd-&gt;ElemCount, 1, pcmd-&gt;IdxOffset + global_idx_offset, pcmd-&gt;VtxOffset + global_vtx_offset, 0);
</code><button class="copy-code-button">复制</button></pre></div><div class="heading-wrapper"><h5 data-heading="结束Render Pass命令录制" class="heading" id="结束Render_Pass命令录制"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>结束Render Pass命令录制<div class="heading-after">...</div></h5><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">vkCmdEndRenderPass(fd-&gt;CommandBuffer);
</code><button class="copy-code-button">复制</button></pre></div><div><p><strong>至此，已完成了界面渲染的命令记录。可见，对于每一个元素甚至每一个文字，都会提交一份顶点、索引(虽然顶点和索引是整体储存在两个Buffer里的)、纹理数据，一个元素就是一个drawcall</strong></p></div></div></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="结束并提交Command Buffer" class="heading" id="结束并提交Command_Buffer"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>结束并提交Command Buffer<div class="heading-after">...</div></h3><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Submit command buffer
vkCmdEndRenderPass(fd-&gt;CommandBuffer);
{
    // 输出颜色图
    VkPipelineStageFlags wait_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    // submit的信息
    VkSubmitInfo info = {};
    info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    info.waitSemaphoreCount = 1;
    // 在执行这一系列指令开始时等待的semaphore
    info.pWaitSemaphores = &amp;image_acquired_semaphore;
    info.pWaitDstStageMask = &amp;wait_stage;
    info.commandBufferCount = 1;
    info.pCommandBuffers = &amp;fd-&gt;CommandBuffer;
    // 在执行完毕后signal的semaphore
    info.signalSemaphoreCount = 1;
    info.pSignalSemaphores = &amp;render_complete_semaphore;

    err = vkEndCommandBuffer(fd-&gt;CommandBuffer);
    check_vk_result(err);
    err = vkQueueSubmit(g_Queue, 1, &amp;info, fd-&gt;Fence);
    check_vk_result(err);
}
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h3 data-heading="更新窗口" class="heading" id="更新窗口"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>更新窗口<div class="heading-after">...</div></h3><div class="heading-children"><div><p>调用这两个函数。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">ImGui::UpdatePlatformWindows();
ImGui::RenderPlatformWindowsDefault();
</code><button class="copy-code-button">复制</button></pre></div><div class="heading-wrapper"><h4 data-heading="GLFW创建窗口" class="heading" id="GLFW创建窗口"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>GLFW创建窗口<div class="heading-after">...</div></h4><div class="heading-children"><div><p>函数原型是static void ImGui_ImplGlfw_CreateWindow(ImGuiViewport* viewport)。看起来是通过Viewport来创建的Window。</p></div><div><p>使用glfwCreateWindow并在viewport data内储存了窗口指针，同时ImGUI的viewport也会储存窗口指针和windows handle。</p></div></div></div><div class="heading-wrapper"><h4 data-heading="为窗口创建回调函数" class="heading" id="为窗口创建回调函数"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>为窗口创建回调函数<div class="heading-after">...</div></h4><div class="heading-children"><div><p>ImGUI接管GLFW的事件。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Install GLFW callbacks for secondary viewports
glfwSetWindowFocusCallback(vd-&gt;Window, ImGui_ImplGlfw_WindowFocusCallback);
glfwSetCursorEnterCallback(vd-&gt;Window, ImGui_ImplGlfw_CursorEnterCallback);
glfwSetCursorPosCallback(vd-&gt;Window, ImGui_ImplGlfw_CursorPosCallback);
glfwSetMouseButtonCallback(vd-&gt;Window, ImGui_ImplGlfw_MouseButtonCallback);
glfwSetScrollCallback(vd-&gt;Window, ImGui_ImplGlfw_ScrollCallback);
glfwSetKeyCallback(vd-&gt;Window, ImGui_ImplGlfw_KeyCallback);
glfwSetCharCallback(vd-&gt;Window, ImGui_ImplGlfw_CharCallback);
glfwSetWindowCloseCallback(vd-&gt;Window, ImGui_ImplGlfw_WindowCloseCallback);
glfwSetWindowPosCallback(vd-&gt;Window, ImGui_ImplGlfw_WindowPosCallback);
glfwSetWindowSizeCallback(vd-&gt;Window, ImGui_ImplGlfw_WindowSizeCallback);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="创建Surface渲染Window" class="heading" id="创建Surface渲染Window"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建Surface渲染Window<div class="heading-after">...</div></h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="创建平台相关的Surface。" class="heading" id="创建平台相关的Surface。"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建平台相关的Surface。<div class="heading-after">...</div></h5><div class="heading-children"><div><p>而后检测硬件是否支持WSI。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Check for WSI support
VkBool32 res;
vkGetPhysicalDeviceSurfaceSupportKHR(v-&gt;PhysicalDevice, v-&gt;QueueFamily, wd-&gt;Surface, &amp;res);
if (res != VK_TRUE)
{
    IM_ASSERT(0); // Error: no WSI support on physical device
    return;
}
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h5 data-heading="再指明格式和色彩空间。" class="heading" id="再指明格式和色彩空间。"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>再指明格式和色彩空间。<div class="heading-after">...</div></h5><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Select Surface Format
const VkFormat requestSurfaceImageFormat[] = { VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_B8G8R8_UNORM, VK_FORMAT_R8G8B8_UNORM };
const VkColorSpaceKHR requestSurfaceColorSpace = VK_COLORSPACE_SRGB_NONLINEAR_KHR;
wd-&gt;SurfaceFormat = ImGui_ImplVulkanH_SelectSurfaceFormat(v-&gt;PhysicalDevice, wd-&gt;Surface, requestSurfaceImageFormat, (size_t)IM_ARRAYSIZE(requestSurfaceImageFormat), requestSurfaceColorSpace);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h5 data-heading="设置呈现模式" class="heading" id="设置呈现模式"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>设置呈现模式<div class="heading-after">...</div></h5><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Select Present Mode
// FIXME-VULKAN: Even thought mailbox seems to get us maximum framerate with a single window, it halves framerate with a second window etc. (w/ Nvidia and SDK 1.82.1)
VkPresentModeKHR present_modes[] = { VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_IMMEDIATE_KHR, VK_PRESENT_MODE_FIFO_KHR };
wd-&gt;PresentMode = ImGui_ImplVulkanH_SelectPresentMode(v-&gt;PhysicalDevice, wd-&gt;Surface, &amp;present_modes[0], IM_ARRAYSIZE(present_modes));
//printf("[vulkan] Secondary window selected PresentMode = %d\n", wd-&gt;PresentMode);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h5 data-heading="创建属于自定义GUI的SwapChain和Command Buffer" class="heading" id="创建属于自定义GUI的SwapChain和Command_Buffer"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>创建属于自定义GUI的SwapChain和Command Buffer<div class="heading-after">...</div></h5><div class="heading-children"><div><p>每个Image或者说FrameBuffer一个Command Buffer。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Create SwapChain, RenderPass, Framebuffer, etc.
wd-&gt;ClearEnable = (viewport-&gt;Flags &amp; ImGuiViewportFlags_NoRendererClear) ? false : true;
ImGui_ImplVulkanH_CreateOrResizeWindow(v-&gt;Instance, v-&gt;PhysicalDevice, v-&gt;Device, wd, v-&gt;QueueFamily, v-&gt;Allocator, (int)viewport-&gt;Size.x, (int)viewport-&gt;Size.y, v-&gt;MinImageCount);
vd-&gt;WindowOwned = true;
</code><button class="copy-code-button">复制</button></pre></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="显示窗口" class="heading" id="显示窗口"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>显示窗口<div class="heading-after">...</div></h4><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">if (is_new_platform_window)
{
// On startup ensure new platform window don't steal focus (give it a few frames, as nested contents may lead to viewport being created a few frames late)
if (g.FrameCount &lt; 3)
viewport-&gt;Flags |= ImGuiViewportFlags_NoFocusOnAppearing;

// Show window
g.PlatformIO.Platform_ShowWindow(viewport);

// Even without focus, we assume the window becomes front-most.
// This is useful for our platform z-order heuristic when io.MouseHoveredViewport is not available.
if (viewport-&gt;LastFrontMostStampCount != g.ViewportFrontMostStampCount)
viewport-&gt;LastFrontMostStampCount = ++g.ViewportFrontMostStampCount;
}
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="设置focus" class="heading" id="设置focus"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>设置focus<div class="heading-after">...</div></h4><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">// Update our implicit z-order knowledge of platform windows, which is used when the backend cannot provide io.MouseHoveredViewport.
// When setting Platform_GetWindowFocus, it is expected that the platform backend can handle calls without crashing if it doesn't have data stored.
// FIXME-VIEWPORT: We should use this information to also set dear imgui-side focus, allowing us to handle os-level alt+tab.
if (g.PlatformIO.Platform_GetWindowFocus != NULL)
{
    ImGuiViewportP* focused_viewport = NULL;
    for (int n = 0; n &lt; g.Viewports.Size &amp;&amp; focused_viewport == NULL; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        if (viewport-&gt;PlatformWindowCreated)
            if (g.PlatformIO.Platform_GetWindowFocus(viewport))
                focused_viewport = viewport;
    }

    // Store a tag so we can infer z-order easily from all our windows
    // We compare PlatformLastFocusedViewportId so newly created viewports with _NoFocusOnAppearing flag
    // will keep the front most stamp instead of losing it back to their parent viewport.
    if (focused_viewport &amp;&amp; g.PlatformLastFocusedViewportId != focused_viewport-&gt;ID)
    {
        if (focused_viewport-&gt;LastFrontMostStampCount != g.ViewportFrontMostStampCount)
            focused_viewport-&gt;LastFrontMostStampCount = ++g.ViewportFrontMostStampCount;
        g.PlatformLastFocusedViewportId = focused_viewport-&gt;ID;
    }
}
</code><button class="copy-code-button">复制</button></pre></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="渲染窗口" class="heading" id="渲染窗口"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>渲染窗口<div class="heading-after">...</div></h3><div class="heading-children"><div><p>大的要来了！</p></div><div><p>void ImGui::RenderPlatformWindowsDefault(void<em> platform_render_arg, void</em> renderer_render_arg)这个函数是默认的渲染窗口的函数，修改了ImGUI的渲染方式后可以自定义此渲染函数。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">//    ImGuiPlatformIO&amp; platform_io = ImGui::GetPlatformIO();
//    for (int i = 1; i &lt; platform_io.Viewports.Size; i++)
//        if ((platform_io.Viewports[i]-&gt;Flags &amp; ImGuiViewportFlags_Minimized) == 0)
//            MyRenderFunction(platform_io.Viewports[i], my_args);
//    for (int i = 1; i &lt; platform_io.Viewports.Size; i++)
//        if ((platform_io.Viewports[i]-&gt;Flags &amp; ImGuiViewportFlags_Minimized) == 0)
//            MySwapBufferFunction(platform_io.Viewports[i], my_args);
</code><button class="copy-code-button">复制</button></pre></div><div><p>此函数会对每个viewport调用如下函数：</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">if (platform_io.Platform_RenderWindow) platform_io.Platform_RenderWindow(viewport, platform_render_arg);
if (platform_io.Renderer_RenderWindow) platform_io.Renderer_RenderWindow(viewport, renderer_render_arg);
</code><button class="copy-code-button">复制</button></pre></div><div><p>platform_io.Platform_RenderWindow函数其实就是将glfw的上下文设置为viewport对应的window。</p></div><div><p>而platform_io.Renderer_RenderWindow函数是真正进行渲染的。</p></div><div class="heading-wrapper"><h4 data-heading="获取下一个Image" class="heading" id="获取下一个Image"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>获取下一个Image<div class="heading-after">...</div></h4><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">err = vkAcquireNextImageKHR(v-&gt;Device, wd-&gt;Swapchain, UINT64_MAX, fsd-&gt;ImageAcquiredSemaphore, VK_NULL_HANDLE, &amp;wd-&gt;FrameIndex);
check_vk_result(err);
fd = &amp;wd-&gt;Frames[wd-&gt;FrameIndex];
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="自旋等待Fences" class="heading" id="自旋等待Fences"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>自旋等待Fences<div class="heading-after">...</div></h4><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">err = vkWaitForFences(v-&gt;Device, 1, &amp;fd-&gt;Fence, VK_TRUE, 100);
if (err == VK_SUCCESS) break;
if (err == VK_TIMEOUT) continue;
check_vk_result(err);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="重置并开始录制Command Buffer" class="heading" id="重置并开始录制Command_Buffer"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>重置并开始录制Command Buffer<div class="heading-after">...</div></h4><div class="heading-children"><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">err = vkResetCommandPool(v-&gt;Device, fd-&gt;CommandPool, 0);
check_vk_result(err);
VkCommandBufferBeginInfo info = {};
info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
info.flags |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
err = vkBeginCommandBuffer(fd-&gt;CommandBuffer, &amp;info);
check_vk_result(err);
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="绑定RenderPass并开始录制" class="heading" id="绑定RenderPass并开始录制"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>绑定RenderPass并开始录制<div class="heading-after">...</div></h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="使用交换链显示窗口" class="heading" id="使用交换链显示窗口"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>使用交换链显示窗口<div class="heading-after">...</div></h3><div class="heading-children"><div><p>先进行platform_io.Platform_SwapBuffers，但好像什么都没执行。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">if (platform_io.Platform_SwapBuffers) platform_io.Platform_SwapBuffers(viewport, platform_render_arg);
if (platform_io.Renderer_SwapBuffers) platform_io.Renderer_SwapBuffers(viewport, renderer_render_arg);
</code><button class="copy-code-button">复制</button></pre></div><div><p>然后platform_io.Renderer_SwapBuffers。</p></div><div><p>需要先创建PresentInfo，而PresentInfo里面包含了Semaphore。</p></div><div><pre class="language-none" tabindex="0"><code class="language-c++ language-none is-loaded">ImGui_ImplVulkanH_FrameSemaphores* fsd = &amp;wd-&gt;FrameSemaphores[wd-&gt;SemaphoreIndex];
VkPresentInfoKHR info = {};
info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
info.waitSemaphoreCount = 1;
// vkQueuePresentKHR发出wait的指令，直到RenderCompleteSemaphore被管线渲染完毕才会执行此指令
info.pWaitSemaphores = &amp;fsd-&gt;RenderCompleteSemaphore;
info.swapchainCount = 1;
// 设置SwapChain
info.pSwapchains = &amp;wd-&gt;Swapchain;
// 设置用作输出的Image
info.pImageIndices = &amp;present_index;
err = vkQueuePresentKHR(v-&gt;Queue, &amp;info);
</code><button class="copy-code-button">复制</button></pre></div><div><p>执行完vkQueuePresentKHR，我们的窗口就得到了更新！</p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="一些概念" class="heading" id="一些概念"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>一些概念<div class="heading-after">...</div></h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="Image | ImageView | FrameBuffer | RenderTarget | Attachment" class="heading" id="Image_|_ImageView_|_FrameBuffer_|_RenderTarget_|_Attachment"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Image | ImageView | FrameBuffer | RenderTarget | Attachment<div class="heading-after">...</div></h2><div class="heading-children"><div><p>图片信息真正的储存位置是VkMemory，VkDeviceMemory，以字节形式存储。<br>而Image首先包含了一些色彩格式之类的元信息，然后提供了使用Texel进行访问RGBA的方法。<br>ImageView就是提供了以不同view来读取Image信息的方法。例如提供了reinterpret方法，可以将原本的RGBA给reinterpret成FT(F=RG, T=BA)、读取Image指定mip的数据、读取Image的指定array(没大懂)。</p></div><div><p>Attachment分为Color和Depth，但Attachment正如其名，只是一个附件，只储存了一些元信息。</p></div><div><p>FrameBuffer将RenderPass和对应的Attachment绑定到一起。</p></div><div><p>RenderTarget是一个Subpass渲染的结果，但是好像在Vulkan api里并不存在RT的概念，而是通过Attachments来实现的，一个Subpass会接受来自上一个Subpass的Attachments作为输入，然后又会输出计算后的Attachments。</p></div><div><img style="zoom:67%" alt="FrameBuffers" src="app://4f89245e4b0fbc8f4c3f1bbebd389eecada3/C:/Users/MECHREV/Downloads/FrameBuffers.png" referrerpolicy="no-referrer"></div><div><p><img alt="K0NRD" src="app://4f89245e4b0fbc8f4c3f1bbebd389eecada3/C:/%5CUsers%5CMECHREV%5CDownloads%5CK0NRD.png" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h2 data-heading="Command Buffer状态" class="heading" id="Command_Buffer状态"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle" style="width:24px;max-width:100%"><path d="M3 8L12 17L21 8"></path></svg></div>Command Buffer状态<div class="heading-after">...</div></h2><div class="heading-children"><div><p><a data-tooltip-position="top" aria-label="https://blog.csdn.net/hbar1973/article/details/123359353" rel="noopener" class="external-link" href="https://blog.csdn.net/hbar1973/article/details/123359353" target="_blank">这篇文章</a>写得蛮不错(但文字功底是真的拉)。</p></div><div><blockquote><p>下面聊一下command buffer的生命周期，每个command buffer都一定存在于其中一个状态中：</p><ul><li data-line="2"><strong>Initial</strong>：当创建一个command buffer的时候，它的初始状态就是initial state。一些命令可以将一个command buffer（或一组command buffers）从executable、recording、invalid状态置回该状态。initial 状态的command buffers只能被moved to recording状态，或者释放；</li><li data-line="3"><strong>Recording</strong>：<code>vkBeginCommandBuffer</code>将command buffer的状态从initial 状态切换到 recording状态。一旦command buffer处于recording状态，则可以通过vkCmd*命令来对该command buffer进行录制；</li><li data-line="4"><strong>Executable</strong>：<code>vkEndCommandBuffer</code>用于结束一个command buffer的录制，并将其从recording state 切换到 executable state。executable commdn buffers可以被 submitted、reset或者 recorded to another command buffer；</li><li data-line="5"><strong>Pending</strong>：Queue submission of a command buffer将command buffer的状态从executable state切换到pending state。当在pending state的时候，应用程序不得以任何方式修改command buffer————因为device可能正在处理command buffer中录制的command。一旦command buffer执行完毕，该状态将会被revert到executable state（如果该command buffer录制的时候打了 <code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code> flag，则会被move to invalid state）。a synchronization command should被用于监测这个事情的发生；</li><li data-line="6"><strong>Invalid</strong>：一些操作，比如：修改或者删除command buffer中某个command所使用的资源，都会导致command buffer的状态切换到invalid state。invalid state的command buffer只能被reset或者释放。<br><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/f556c979c7334e42aa0e55c6303ec154.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAaGJhcjE5NzM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" referrerpolicy="no-referrer"></li></ul><p>在command buffer上操作任何command，都有其自身的要求，它要求command buffer必须处于什么状态，这在该command 的有效使用限制中有详细说明。</p><p>reset 一个command buffer 将丢弃先前录制的command，并将command buffer置于initial state。 reset是调用 <code>vkResetCommandBuffer</code>、<code>vkResetCommandPool</code>、或者<code>vkBeginCommandBuffer</code>的一部分（该命令还会使得command buffer处于录制状态）。</p><p>Secondary command buffers也通过<code>vkCmdExecuteCommands</code>被记录到primary command buffer中。这将两个command buffer的生命周期联系在一起——如果primary command buffer被submit到queue，那么primary command buffer以及其关联的所有secondary command buffer都将move to pending state。一旦primary command buffer执行完毕，其关联的secondary command buffer也就都执行完毕了。当每个command buffer都执行完毕后，它们将分别进入它们相应的完成状态（如上所述，executable state或者invalid state）。</p><p>当一个secondary command buffer move to invalid state或者initial state，那么它关联的所有primary command buffer都将move to invalid state。而primary command buffer切换状态，不会影响secondary command buffer的状态。（需要注意的是：如果reset或者释放一个primary command buffer，会删除所有关联的secondary command buffer的lifecycle linkage）。</p><p>Command buffer是从command pool中获取内存创建的，这样的话，可以将多个command buffer的创建成本平摊。command pool是externally synchronized，意味着一个command pool不能被多个线程同时使用。这包括：pool中创建的command buffer录制命令，以及分配、释放和重置command buffer或者pool本身。</p></blockquote></div><div class="mod-footer"></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-gutter"><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-container"><div class="sidebar-sizer"><div class="sidebar-content-positioner"><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder"><div class="graph-view-container"><div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div><canvas id="graph-canvas" width="512px" height="512px"></canvas></div></div></div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button is-collapsed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area"><div class="tree-item" data-depth="1"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#ImGui中Vulkan的窗口渲染"><span class="tree-item-title"><p>ImGui中Vulkan的窗口渲染</p></span></a></div><div class="tree-item-children"><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Setup_Vulkan"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>Setup Vulkan</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#首先先声明一下后面会使用的变量"><span class="tree-item-title"><p>首先先声明一下后面会使用的变量</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建Vulkan_Instance"><span class="tree-item-title"><p>创建Vulkan Instance</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#获取GPU设备"><span class="tree-item-title"><p>获取GPU设备</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#选择队列族"><span class="tree-item-title"><p>选择队列族</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建逻辑设备"><span class="tree-item-title"><p>创建逻辑设备</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建描述符池"><span class="tree-item-title"><p>创建描述符池</p></span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建SwapChain"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>创建SwapChain</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#预先准备"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>预先准备</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建surface"><span class="tree-item-title"><p>创建surface</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建色彩空间和图像(像素)格式"><span class="tree-item-title"><p>创建色彩空间和图像(像素)格式</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建呈现模式信息"><span class="tree-item-title"><p>创建呈现模式信息</p></span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建SwapChain"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>创建SwapChain</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建Render_Pass"><span class="tree-item-title"><p>创建Render Pass</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建ImageView"><span class="tree-item-title"><p>创建ImageView</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建FrameBuffer"><span class="tree-item-title"><p>创建FrameBuffer</p></span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建Command_Pool和CommandBuffers及其他"><span class="tree-item-title"><p>创建Command Pool和CommandBuffers及其他</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建管线"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>创建管线</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Set_DescriptorSetLayout"><span class="tree-item-title"><p>Set DescriptorSetLayout</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Set_PipelineLayout"><span class="tree-item-title"><p>Set PipelineLayout</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建Shader"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>创建Shader</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Shader_Module"><span class="tree-item-title"><p>Shader Module</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Shader_Stage"><span class="tree-item-title"><p>Shader Stage</p></span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建Vertex_Input_Description"><span class="tree-item-title"><p>创建Vertex Input Description</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建管线信息"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>创建管线信息</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Shader_Stage"><span class="tree-item-title"><p>Shader Stage</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Vertex_Input"><span class="tree-item-title"><p>Vertex Input</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Assembly"><span class="tree-item-title"><p>Assembly</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Viewport"><span class="tree-item-title"><p>Viewport</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#rasterization"><span class="tree-item-title"><p>rasterization</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Multisample"><span class="tree-item-title"><p>Multisample</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#ColorBlendAttachment"><span class="tree-item-title"><p>ColorBlendAttachment</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Stencil"><span class="tree-item-title"><p>Stencil</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#ColorBlend"><span class="tree-item-title"><p>ColorBlend</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Dynamic"><span class="tree-item-title"><p>Dynamic</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建管线"><span class="tree-item-title"><p>创建管线</p></span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#渲染字体"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>渲染字体</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#字体纹理"><span class="tree-item-title"><p>字体纹理</p></span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#进入MainLoop"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>进入MainLoop</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#glfwPollEvents()"><span class="tree-item-title"><p>glfwPollEvents()</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#设置Swap_Chain大小"><span class="tree-item-title"><p>设置Swap Chain大小</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#开始Dear_ImGUI帧"><span class="tree-item-title"><p>开始Dear ImGUI帧</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#渲染帧"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>渲染帧</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#获取Swap_Chain中下一个Image"><span class="tree-item-title"><p>获取Swap Chain中下一个Image</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#重置命令缓冲池开始录制命令缓冲"><span class="tree-item-title"><p>重置命令缓冲池开始录制命令缓冲</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#记录ImGUI中的Command"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>记录ImGUI中的Command</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="5"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#开始Render_Pass"><span class="tree-item-title"><p>开始Render Pass</p></span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#准备Vertex和Index数据(Buffer)"><span class="tree-item-title"><p>准备Vertex和Index数据(Buffer)</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#记录Pipeline指令"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>记录Pipeline指令</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="5"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#pipeline绑定"><span class="tree-item-title"><p>pipeline绑定</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="5"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Buffer绑定"><span class="tree-item-title"><p>Buffer绑定</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="5"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建ViewPort"><span class="tree-item-title"><p>创建ViewPort</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="5"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#设置变换变量"><span class="tree-item-title"><p>设置变换变量</p></span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#绘制DrawList"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>绘制DrawList</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="5"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#结束Render_Pass命令录制"><span class="tree-item-title"><p>结束Render Pass命令录制</p></span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#结束并提交Command_Buffer"><span class="tree-item-title"><p>结束并提交Command Buffer</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#更新窗口"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>更新窗口</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#GLFW创建窗口"><span class="tree-item-title"><p>GLFW创建窗口</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#为窗口创建回调函数"><span class="tree-item-title"><p>为窗口创建回调函数</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建Surface渲染Window"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>创建Surface渲染Window</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="5"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建平台相关的Surface。"><span class="tree-item-title"><p>创建平台相关的Surface。</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="5"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#再指明格式和色彩空间。"><span class="tree-item-title"><p>再指明格式和色彩空间。</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="5"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#设置呈现模式"><span class="tree-item-title"><p>设置呈现模式</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="5"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#创建属于自定义GUI的SwapChain和Command_Buffer"><span class="tree-item-title"><p>创建属于自定义GUI的SwapChain和Command Buffer</p></span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#显示窗口"><span class="tree-item-title"><p>显示窗口</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#设置focus"><span class="tree-item-title"><p>设置focus</p></span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#渲染窗口"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><p>渲染窗口</p></span></a></div><div class="tree-item-children" style="display:none"><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#获取下一个Image"><span class="tree-item-title"><p>获取下一个Image</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#自旋等待Fences"><span class="tree-item-title"><p>自旋等待Fences</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#重置并开始录制Command_Buffer"><span class="tree-item-title"><p>重置并开始录制Command Buffer</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#绑定RenderPass并开始录制"><span class="tree-item-title"><p>绑定RenderPass并开始录制</p></span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#使用交换链显示窗口"><span class="tree-item-title"><p>使用交换链显示窗口</p></span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#一些概念"><span class="tree-item-title"><p>一些概念</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Image_|_ImageView_|_FrameBuffer_|_RenderTarget_|_Attachment"><span class="tree-item-title"><p>Image | ImageView | FrameBuffer | RenderTarget | Attachment</p></span></a></div><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><div class="tree-item-contents"><a class="internal-link tree-item-link" href="#Command_Buffer状态"><span class="tree-item-title"><p>Command Buffer状态</p></span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></div></div></div></body></html>